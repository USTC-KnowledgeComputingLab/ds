{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"DS - A Deductive System","text":"<p>A deductive system for logical inference, implemented in C++. The library provides bindings for Python (via pybind11) and TypeScript/JavaScript (via Emscripten/WebAssembly).</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Multi-Language Support: Use the same deductive system in C++, Python, or TypeScript/JavaScript</li> <li>Logical Terms: Work with variables, items (constants/functors), and lists</li> <li>Rule-Based Inference: Define rules and facts, perform logical deduction</li> <li>Unification and Matching: Unify terms and match rules</li> <li>Search Engine: Built-in search mechanism for iterative inference</li> <li>WebAssembly: Run inference in the browser or Node.js environments</li> <li>Type-Safe: Strong typing support in TypeScript and Python</li> </ul>"},{"location":"index.html#supported-languages","title":"Supported Languages","text":"TypeScriptPythonC++ <pre><code>import { term_t } from \"atsds\";\n\nconst term = new term_t(\"(hello world)\");\nconsole.log(term.toString());\n// Output: (hello world)\n</code></pre> <pre><code>import apyds\nprint(f\"Version: {apyds.__version__}\")\n\nterm = apyds.Term(\"(hello world)\")\nprint(term)  # (hello world)\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto term = ds::text_to_term(\"(hello world)\", 1000);\n    std::cout &lt;&lt; ds::term_to_text(term.get(), 1000).get() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"index.html#quick-links","title":"Quick Links","text":"<ul> <li>Installation - Install DS for your preferred language</li> <li>Quick Start - Get up and running in minutes</li> <li>Core Concepts - Learn about terms, rules, and inference</li> <li>API Reference - Complete API documentation</li> <li>Examples - Working code examples</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0 or later.</p>"},{"location":"api/cpp.html","title":"C++ API Reference","text":"<p>This page documents the C++ API for the DS library. The documentation is generated from the C++ source code.</p> <p>All classes and functions are in the <code>ds</code> namespace.</p>"},{"location":"api/cpp.html#headers","title":"Headers","text":"<pre><code>#include &lt;ds/ds.hh&gt;        // All basic types\n#include &lt;ds/search.hh&gt;    // Search engine\n#include &lt;ds/utility.hh&gt;   // Helper functions\n</code></pre>"},{"location":"api/cpp.html#string_t","title":"string_t","text":"<p>String handling class. Defined in <code>&lt;ds/string.hh&gt;</code>.</p>"},{"location":"api/cpp.html#methods","title":"Methods","text":""},{"location":"api/cpp.html#data_size","title":"data_size()","text":"<p>Get the size of the string data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head","title":"head()","text":"<p>Get a pointer to the first byte.</p> <pre><code>std::byte* head();\n</code></pre>"},{"location":"api/cpp.html#tail","title":"tail()","text":"<p>Get a pointer past the last byte.</p> <pre><code>std::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print","title":"print()","text":"<p>Output the string to a buffer.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#scan","title":"scan()","text":"<p>Read a string from a buffer.</p> <pre><code>const char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#variable_t","title":"variable_t","text":"<p>Logical variable class. Defined in <code>&lt;ds/variable.hh&gt;</code>.</p> <p>Variables represent placeholders that can be unified with other terms.</p>"},{"location":"api/cpp.html#methods_1","title":"Methods","text":""},{"location":"api/cpp.html#name","title":"name()","text":"<p>Get the name of the variable (without backtick prefix).</p> <pre><code>string_t* name();\n</code></pre>"},{"location":"api/cpp.html#data_size_1","title":"data_size()","text":"<p>Get the size of the variable data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#item_t","title":"item_t","text":"<p>Item (constant/functor) class. Defined in <code>&lt;ds/item.hh&gt;</code>.</p> <p>Items represent atomic values or function symbols.</p>"},{"location":"api/cpp.html#methods_2","title":"Methods","text":""},{"location":"api/cpp.html#name_1","title":"name()","text":"<p>Get the name of the item.</p> <pre><code>string_t* name();\n</code></pre>"},{"location":"api/cpp.html#data_size_2","title":"data_size()","text":"<p>Get the size of the item data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_1","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_1","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#list_t","title":"list_t","text":"<p>List class. Defined in <code>&lt;ds/list.hh&gt;</code>.</p> <p>Lists contain ordered sequences of terms.</p>"},{"location":"api/cpp.html#methods_3","title":"Methods","text":""},{"location":"api/cpp.html#length","title":"length()","text":"<p>Get the number of elements in the list.</p> <pre><code>length_t length();\n</code></pre>"},{"location":"api/cpp.html#getitem","title":"getitem()","text":"<p>Get an element by index.</p> <pre><code>term_t* getitem(length_t index);\n</code></pre>"},{"location":"api/cpp.html#data_size_3","title":"data_size()","text":"<p>Get the size of the list data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_2","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_2","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#term_t","title":"term_t","text":"<p>General term class. Defined in <code>&lt;ds/term.hh&gt;</code>.</p> <p>A term can be a variable, item, or list.</p>"},{"location":"api/cpp.html#enum-term_type_t","title":"Enum: term_type_t","text":"<pre><code>enum class term_type_t : min_uint_t {\n    null = 0,\n    variable = 1,\n    item = 2,\n    list = 3\n};\n</code></pre>"},{"location":"api/cpp.html#methods_4","title":"Methods","text":""},{"location":"api/cpp.html#get_type","title":"get_type()","text":"<p>Get the type of this term.</p> <pre><code>term_type_t get_type();\n</code></pre>"},{"location":"api/cpp.html#is_null","title":"is_null()","text":"<p>Check if the term is null.</p> <pre><code>bool is_null();\n</code></pre>"},{"location":"api/cpp.html#variable-item-list","title":"variable() / item() / list()","text":"<p>Get the underlying value as the specific type. Returns nullptr if the term is not of that type.</p> <pre><code>variable_t* variable();\nitem_t* item();\nlist_t* list();\n</code></pre>"},{"location":"api/cpp.html#set_type-set_null-set_variable-set_item-set_list","title":"set_type() / set_null() / set_variable() / set_item() / set_list()","text":"<p>Set the term type.</p> <pre><code>term_t* set_type(term_type_t type, std::byte* check_tail = nullptr);\nterm_t* set_null(std::byte* check_tail = nullptr);\nterm_t* set_variable(std::byte* check_tail = nullptr);\nterm_t* set_item(std::byte* check_tail = nullptr);\nterm_t* set_list(std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#data_size_4","title":"data_size()","text":"<p>Get the size of the term data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_3","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_3","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#ground","title":"ground()","text":"<p>Ground this term using a dictionary to substitute variables.</p> <pre><code>term_t* ground(term_t* term, term_t* dictionary, const char* scope, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#match","title":"match()","text":"<p>Match two terms and produce a unification dictionary.</p> <pre><code>term_t* match(term_t* term_1, term_t* term_2, \n              const char* scope_1, const char* scope_2, \n              std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#rename","title":"rename()","text":"<p>Rename variables by adding prefix and suffix.</p> <pre><code>term_t* rename(term_t* term, term_t* prefix_and_suffix, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#rule_t","title":"rule_t","text":"<p>Logical rule class. Defined in <code>&lt;ds/rule.hh&gt;</code>.</p> <p>A rule consists of premises and a conclusion.</p>"},{"location":"api/cpp.html#methods_5","title":"Methods","text":""},{"location":"api/cpp.html#conclusion","title":"conclusion()","text":"<p>Get the conclusion of the rule.</p> <pre><code>term_t* conclusion();\n</code></pre>"},{"location":"api/cpp.html#only_conclusion","title":"only_conclusion()","text":"<p>Get the conclusion only if there are no premises. Returns nullptr otherwise.</p> <pre><code>term_t* only_conclusion();\n</code></pre>"},{"location":"api/cpp.html#premises","title":"premises()","text":"<p>Get a premise by index.</p> <pre><code>term_t* premises(length_t index);\n</code></pre>"},{"location":"api/cpp.html#premises_count","title":"premises_count()","text":"<p>Get the number of premises.</p> <pre><code>length_t premises_count();\n</code></pre>"},{"location":"api/cpp.html#valid","title":"valid()","text":"<p>Check if the rule is valid.</p> <pre><code>bool valid();\n</code></pre>"},{"location":"api/cpp.html#data_size_5","title":"data_size()","text":"<p>Get the size of the rule data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_4","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_4","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#ground_1","title":"ground()","text":"<p>Ground this rule using a dictionary.</p> <pre><code>rule_t* ground(rule_t* rule, term_t* dictionary, const char* scope, \n               std::byte* check_tail = nullptr);\nrule_t* ground(rule_t* rule, rule_t* dictionary, const char* scope, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#match_1","title":"match()","text":"<p>Match this rule with a fact.</p> <pre><code>rule_t* match(rule_t* rule_1, rule_t* rule_2, \n              std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#rename_1","title":"rename()","text":"<p>Rename variables in this rule.</p> <pre><code>rule_t* rename(rule_t* rule, rule_t* prefix_and_suffix, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#search_t","title":"search_t","text":"<p>Search engine class. Defined in <code>&lt;ds/search.hh&gt;</code>.</p> <p>Manages a knowledge base and performs logical inference.</p>"},{"location":"api/cpp.html#constructor","title":"Constructor","text":"<pre><code>search_t(length_t limit_size, length_t buffer_size);\n</code></pre> <p>Parameters:</p> <ul> <li><code>limit_size</code>: Maximum size for each stored rule/fact</li> <li><code>buffer_size</code>: Size of the internal buffer for operations</li> </ul>"},{"location":"api/cpp.html#methods_6","title":"Methods","text":""},{"location":"api/cpp.html#set_limit_size","title":"set_limit_size()","text":"<p>Set the maximum rule/fact size.</p> <pre><code>void set_limit_size(length_t limit_size);\n</code></pre>"},{"location":"api/cpp.html#set_buffer_size","title":"set_buffer_size()","text":"<p>Set the internal buffer size.</p> <pre><code>void set_buffer_size(length_t buffer_size);\n</code></pre>"},{"location":"api/cpp.html#reset","title":"reset()","text":"<p>Clear all rules and facts.</p> <pre><code>void reset();\n</code></pre>"},{"location":"api/cpp.html#add","title":"add()","text":"<p>Add a rule or fact from text.</p> <pre><code>bool add(std::string_view text);\n</code></pre>"},{"location":"api/cpp.html#execute","title":"execute()","text":"<p>Execute one round of inference.</p> <pre><code>length_t execute(const std::function&lt;bool(rule_t*)&gt;&amp; callback);\n</code></pre> <p>Parameters:</p> <ul> <li><code>callback</code>: Function called for each new inference. Return false to continue, true to stop.</li> </ul> <p>Returns: The number of new inferences generated.</p>"},{"location":"api/cpp.html#utility-functions","title":"Utility Functions","text":"<p>Helper functions in <code>&lt;ds/utility.hh&gt;</code>.</p>"},{"location":"api/cpp.html#text_to_term","title":"text_to_term()","text":"<p>Parse text into a term object.</p> <pre><code>std::unique_ptr&lt;term_t&gt; text_to_term(const char* text, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>text</code>: The text representation of the term</li> <li><code>length</code>: Maximum size for the resulting binary term</li> </ul> <p>Returns: A unique_ptr to the created term, or nullptr if length exceeded.</p>"},{"location":"api/cpp.html#term_to_text","title":"term_to_text()","text":"<p>Convert a term object to text.</p> <pre><code>std::unique_ptr&lt;char&gt; term_to_text(term_t* term, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>term</code>: The binary term to convert</li> <li><code>length</code>: Maximum size for the resulting text</li> </ul> <p>Returns: A unique_ptr to the text, or nullptr if length exceeded.</p>"},{"location":"api/cpp.html#text_to_rule","title":"text_to_rule()","text":"<p>Parse text into a rule object.</p> <pre><code>std::unique_ptr&lt;rule_t&gt; text_to_rule(const char* text, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>text</code>: The text representation of the rule</li> <li><code>length</code>: Maximum size for the resulting binary rule</li> </ul> <p>Returns: A unique_ptr to the created rule, or nullptr if length exceeded.</p>"},{"location":"api/cpp.html#rule_to_text","title":"rule_to_text()","text":"<p>Convert a rule object to text.</p> <pre><code>std::unique_ptr&lt;char&gt; rule_to_text(rule_t* rule, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>rule</code>: The binary rule to convert</li> <li><code>length</code>: Maximum size for the resulting text</li> </ul> <p>Returns: A unique_ptr to the text, or nullptr if length exceeded.</p>"},{"location":"api/cpp.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating the C++ API:</p> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    const int buffer_size = 1000;\n\n    // Create terms using utility functions\n    auto term = ds::text_to_term(\"(f `x `y)\", buffer_size);\n\n    std::cout &lt;&lt; \"Term: \" &lt;&lt; ds::term_to_text(term.get(), buffer_size).get() &lt;&lt; std::endl;\n\n    // Work with rules\n    auto fact = ds::text_to_rule(\"(parent john mary)\", buffer_size);\n    auto rule = ds::text_to_rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\", buffer_size);\n\n    std::cout &lt;&lt; \"\\nFact:\\n\" &lt;&lt; ds::rule_to_text(fact.get(), buffer_size).get();\n    std::cout &lt;&lt; \"Rule premises: \" &lt;&lt; rule-&gt;premises_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Rule conclusion: \" &lt;&lt; ds::term_to_text(rule-&gt;conclusion(), buffer_size).get() &lt;&lt; std::endl;\n\n    // Search engine\n    ds::search_t search(1000, 10000);\n\n    // Add rules and facts\n    search.add(\"p q\");  // p implies q\n    search.add(\"q r\");  // q implies r\n    search.add(\"p\");    // fact: p\n\n    std::cout &lt;&lt; \"\\nRunning inference:\" &lt;&lt; std::endl;\n\n    // Execute search\n    auto target = ds::text_to_rule(\"r\", buffer_size);\n    bool found = false;\n\n    while (!found) {\n        auto count = search.execute([&amp;](ds::rule_t* candidate) {\n            std::cout &lt;&lt; \"  Derived: \" &lt;&lt; ds::rule_to_text(candidate, buffer_size).get();\n\n            // Check if this is our target\n            if (candidate-&gt;data_size() == target-&gt;data_size() &amp;&amp;\n                memcmp(candidate-&gt;head(), target-&gt;head(), candidate-&gt;data_size()) == 0) {\n                found = true;\n                return true;  // Stop\n            }\n            return false;  // Continue\n        });\n\n        if (count == 0) {\n            std::cout &lt;&lt; \"  (no more inferences)\" &lt;&lt; std::endl;\n            break;\n        }\n    }\n\n    if (found) {\n        std::cout &lt;&lt; \"Target found!\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"api/python.html","title":"Python API Reference","text":"<p>This page documents the Python API for the <code>apyds</code> package.</p> <pre><code>from apyds import (\n    buffer_size,\n    scoped_buffer_size,\n    String,\n    Variable,\n    Item,\n    List,\n    Term,\n    Rule,\n    Search,\n)\n</code></pre>"},{"location":"api/python.html#buffer_size","title":"buffer_size","text":"<p>Gets the current buffer size, or sets a new buffer size and returns the previous value.</p> <pre><code>def buffer_size(size: int = 0) -&gt; int\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> (optional): The new buffer size to set. If 0 (default), returns current size without modification.</li> </ul> <p>Returns: The previous buffer size value.</p> <p>Example:</p> <pre><code>current_size = buffer_size()       # Get current size\nold_size = buffer_size(2048)       # Set new size, returns old size\n</code></pre>"},{"location":"api/python.html#scoped_buffer_size","title":"scoped_buffer_size","text":"<p>Context manager for temporarily changing the buffer size.</p> <pre><code>@contextmanager\ndef scoped_buffer_size(size: int = 0)\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code>: The temporary buffer size to set.</li> </ul> <p>Example:</p> <pre><code>with scoped_buffer_size(4096):\n    # Operations here use buffer size of 4096\n    pass\n# Buffer size is restored to previous value\n</code></pre>"},{"location":"api/python.html#string","title":"String","text":"<p>Wrapper class for deductive system strings.</p>"},{"location":"api/python.html#constructor","title":"Constructor","text":"<pre><code>def __init__(self, value: String | str | bytes, size: int | None = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string, bytes, or another String)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/python.html#methods","title":"Methods","text":""},{"location":"api/python.html#__str__","title":"__str__()","text":"<p>Convert the value to a string representation.</p> <pre><code>def __str__(self) -&gt; str\n</code></pre>"},{"location":"api/python.html#data","title":"data()","text":"<p>Get the binary representation of the value.</p> <pre><code>def data(self) -&gt; bytes\n</code></pre>"},{"location":"api/python.html#size","title":"size()","text":"<p>Get the size of the data in bytes.</p> <pre><code>def size(self) -&gt; int\n</code></pre> <p>Example:</p> <pre><code>str1 = String(\"hello\")\nstr2 = String(str1.data())  # From binary\nprint(str1)  # \"hello\"\n</code></pre>"},{"location":"api/python.html#variable","title":"Variable","text":"<p>Wrapper class for logical variables in the deductive system.</p>"},{"location":"api/python.html#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, value: Variable | str | bytes, size: int | None = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string starting with backtick, bytes, or another Variable)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/python.html#properties","title":"Properties","text":""},{"location":"api/python.html#name","title":"name","text":"<p>Get the name of this variable (without the backtick prefix).</p> <pre><code>@property\ndef name(self) -&gt; String\n</code></pre> <p>Example:</p> <pre><code>var1 = Variable(\"`X\")\nprint(var1.name)  # \"X\"\nprint(var1)       # \"`X\"\n</code></pre>"},{"location":"api/python.html#item","title":"Item","text":"<p>Wrapper class for items (constants/functors) in the deductive system.</p>"},{"location":"api/python.html#constructor_2","title":"Constructor","text":"<pre><code>def __init__(self, value: Item | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#properties_1","title":"Properties","text":""},{"location":"api/python.html#name_1","title":"name","text":"<p>Get the name of this item.</p> <pre><code>@property\ndef name(self) -&gt; String\n</code></pre> <p>Example:</p> <pre><code>item = Item(\"atom\")\nprint(item.name)  # \"atom\"\n</code></pre>"},{"location":"api/python.html#list","title":"List","text":"<p>Wrapper class for lists in the deductive system.</p>"},{"location":"api/python.html#constructor_3","title":"Constructor","text":"<pre><code>def __init__(self, value: List | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#methods_1","title":"Methods","text":""},{"location":"api/python.html#__len__","title":"__len__()","text":"<p>Get the number of elements in the list.</p> <pre><code>def __len__(self) -&gt; int\n</code></pre>"},{"location":"api/python.html#__getitem__","title":"__getitem__()","text":"<p>Get an element from the list by index.</p> <pre><code>def __getitem__(self, index: int) -&gt; Term\n</code></pre> <p>Example:</p> <pre><code>lst = List(\"(a b c)\")\nprint(len(lst))   # 3\nprint(lst[0])     # \"a\"\n</code></pre>"},{"location":"api/python.html#term","title":"Term","text":"<p>Wrapper class for logical terms in the deductive system. A term can be a variable, item, or list.</p>"},{"location":"api/python.html#constructor_4","title":"Constructor","text":"<pre><code>def __init__(self, value: Term | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#properties_2","title":"Properties","text":""},{"location":"api/python.html#term_1","title":"term","text":"<p>Extracts the underlying term and returns it as its concrete type.</p> <pre><code>@property\ndef term(self) -&gt; Variable | Item | List\n</code></pre>"},{"location":"api/python.html#methods_2","title":"Methods","text":""},{"location":"api/python.html#ground","title":"ground()","text":"<p>Ground this term using a dictionary to substitute variables with values.</p> <pre><code>def ground(self, other: Term, scope: str | None = None) -&gt; Term | None\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: A term representing a dictionary (list of pairs)</li> <li><code>scope</code> (optional): Scope string for variable scoping</li> </ul> <p>Returns: The grounded term, or None if grounding fails.</p> <p>Example:</p> <pre><code>a = Term(\"`a\")\ndict = Term(\"((`a b))\")\nresult = a.ground(dict)\nif result is not None:\n    print(result)  # \"b\"\n</code></pre>"},{"location":"api/python.html#rename","title":"rename()","text":"<p>Rename all variables in this term by adding prefix and suffix.</p> <pre><code>def rename(self, prefix_and_suffix: Term) -&gt; Term | None\n</code></pre> <p>Parameters:</p> <ul> <li><code>prefix_and_suffix</code>: A term with format <code>((prefix) (suffix))</code></li> </ul> <p>Returns: The renamed term, or None if renaming fails.</p> <p>Example:</p> <pre><code>term = Term(\"`x\")\nspec = Term(\"((pre_) (_suf))\")\nresult = term.rename(spec)\nif result is not None:\n    print(result)  # \"`pre_x_suf\"\n</code></pre>"},{"location":"api/python.html#rule","title":"Rule","text":"<p>Wrapper class for logical rules in the deductive system.</p>"},{"location":"api/python.html#constructor_5","title":"Constructor","text":"<pre><code>def __init__(self, value: Rule | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#properties_3","title":"Properties","text":""},{"location":"api/python.html#conclusion","title":"conclusion","text":"<p>Get the conclusion of the rule.</p> <pre><code>@property\ndef conclusion(self) -&gt; Term\n</code></pre>"},{"location":"api/python.html#methods_3","title":"Methods","text":""},{"location":"api/python.html#__len___1","title":"__len__()","text":"<p>Get the number of premises in the rule.</p> <pre><code>def __len__(self) -&gt; int\n</code></pre>"},{"location":"api/python.html#__getitem___1","title":"__getitem__()","text":"<p>Get a premise term by index.</p> <pre><code>def __getitem__(self, index: int) -&gt; Term\n</code></pre>"},{"location":"api/python.html#ground_1","title":"ground()","text":"<p>Ground this rule using a dictionary.</p> <pre><code>def ground(self, other: Rule, scope: str | None = None) -&gt; Rule | None\n</code></pre>"},{"location":"api/python.html#__matmul__-match","title":"__matmul__() / match","text":"<p>Match this rule with another rule using unification.</p> <pre><code>def __matmul__(self, other: Rule) -&gt; Rule | None\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: The rule to match against (must be a fact without premises)</li> </ul> <p>Returns: The matched rule, or None if matching fails.</p> <p>Example:</p> <pre><code>mp = Rule(\"(`p -&gt; `q)\\n`p\\n`q\\n\")\npq = Rule(\"((! (! `x)) -&gt; `x)\")\nresult = mp @ pq\nif result is not None:\n    print(result)\n    # \"(! (! `x))\\n----------\\n`x\\n\"\n</code></pre>"},{"location":"api/python.html#rename_1","title":"rename()","text":"<p>Rename all variables in this rule.</p> <pre><code>def rename(self, prefix_and_suffix: Rule) -&gt; Rule | None\n</code></pre>"},{"location":"api/python.html#search","title":"Search","text":"<p>Search engine for the deductive system.</p>"},{"location":"api/python.html#constructor_6","title":"Constructor","text":"<pre><code>def __init__(self, limit_size: int = 1000, buffer_size: int = 10000)\n</code></pre> <p>Parameters:</p> <ul> <li><code>limit_size</code> (optional): Size of the buffer for storing rules/facts (default: 1000)</li> <li><code>buffer_size</code> (optional): Size of the buffer for internal operations (default: 10000)</li> </ul>"},{"location":"api/python.html#methods_4","title":"Methods","text":""},{"location":"api/python.html#set_limit_size","title":"set_limit_size()","text":"<p>Set the size of the buffer for storing final objects.</p> <pre><code>def set_limit_size(self, limit_size: int) -&gt; None\n</code></pre>"},{"location":"api/python.html#set_buffer_size","title":"set_buffer_size()","text":"<p>Set the buffer size for internal operations.</p> <pre><code>def set_buffer_size(self, buffer_size: int) -&gt; None\n</code></pre>"},{"location":"api/python.html#reset","title":"reset()","text":"<p>Reset the search engine, clearing all rules and facts.</p> <pre><code>def reset(self) -&gt; None\n</code></pre>"},{"location":"api/python.html#add","title":"add()","text":"<p>Add a rule or fact to the knowledge base.</p> <pre><code>def add(self, text: str) -&gt; bool\n</code></pre> <p>Returns: True if successfully added, False otherwise.</p>"},{"location":"api/python.html#execute","title":"execute()","text":"<p>Execute the search engine with a callback for each inferred rule.</p> <pre><code>def execute(self, callback: Callable[[Rule], bool]) -&gt; int\n</code></pre> <p>Parameters:</p> <ul> <li><code>callback</code>: Function called for each candidate rule. Return False to continue, True to stop.</li> </ul> <p>Returns: The number of rules processed.</p> <p>Example:</p> <pre><code>search = Search(1000, 10000)\nsearch.add(\"(`P -&gt; `Q) `P `Q\")\nsearch.add(\"(! (! X))\")\n\ndef callback(candidate):\n    print(candidate)\n    return False  # Continue searching\n\nsearch.execute(callback)\n</code></pre>"},{"location":"api/python.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating most of the API:</p> <pre><code>import apyds\n\n# Configure buffer size for operations\napyds.buffer_size(2048)\n\n# Create terms\nvar = apyds.Variable(\"`X\")\nitem = apyds.Item(\"hello\")\nlst = apyds.List(\"(a b c)\")\nterm = apyds.Term(\"(f `x `y)\")\n\nprint(f\"Variable: {var}, name: {var.name}\")\nprint(f\"Item: {item}, name: {item.name}\")\nprint(f\"List: {lst}, length: {len(lst)}\")\nprint(f\"Term: {term}, type: {type(term.term)}\")\n\n# Work with rules\nfact = apyds.Rule(\"(parent john mary)\")\nrule = apyds.Rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\n\nprint(f\"\\nFact: {fact}\")\nprint(f\"Rule premises: {len(rule)}, conclusion: {rule.conclusion}\")\n\n# Grounding\nterm_a = apyds.Term(\"`a\")\ndictionary = apyds.Term(\"((`a hello))\")\ngrounded = term_a // dictionary\nprint(f\"\\nGrounding `a with ((` hello)): {grounded}\")\n\n# Matching\nmp = apyds.Rule(\"(`p -&gt; `q)\\n`p\\n`q\\n\")\naxiom = apyds.Rule(\"((A) -&gt; B)\")\nmatched = mp @ axiom\nprint(f\"\\nMatching modus ponens with (A -&gt; B):\\n{matched}\")\n\n# Search engine\nsearch = apyds.Search(1000, 10000)\nsearch.add(\"p q\")  # p implies q\nsearch.add(\"q r\")  # q implies r\nsearch.add(\"p\")    # fact: p\n\nprint(\"\\nRunning inference:\")\nfor i in range(3):\n    count = search.execute(lambda r: print(f\"  Derived: {r}\") or False)\n    if count == 0:\n        break\n\n# Using context manager for buffer size\nwith apyds.scoped_buffer_size(4096):\n    big_term = apyds.Term(\"(a b c d e f g h i j)\")\n    print(f\"\\nBig term: {big_term}\")\n</code></pre>"},{"location":"api/typescript.html","title":"TypeScript API Reference","text":"<p>This page documents the TypeScript API for the <code>atsds</code> package. The documentation is generated from the TypeScript source code.</p> <pre><code>import { \n    buffer_size,\n    string_t, \n    variable_t, \n    item_t, \n    list_t, \n    term_t, \n    rule_t, \n    search_t \n} from \"atsds\";\n</code></pre>"},{"location":"api/typescript.html#buffer_size","title":"buffer_size","text":"<p>Gets the current buffer size, or sets a new buffer size and returns the previous value.</p> <pre><code>function buffer_size(size?: number): number;\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> (optional): The new buffer size to set. If 0 or omitted, returns current size without modification.</li> </ul> <p>Returns: The previous buffer size value.</p> <p>Example:</p> <pre><code>const currentSize = buffer_size();     // Get current size\nconst oldSize = buffer_size(2048);     // Set new size, returns old size\n</code></pre>"},{"location":"api/typescript.html#string_t","title":"string_t","text":"<p>Wrapper class for deductive system strings.</p>"},{"location":"api/typescript.html#constructor","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | string_t, size?: number)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string, buffer, or another string_t)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/typescript.html#methods","title":"Methods","text":""},{"location":"api/typescript.html#tostring","title":"toString()","text":"<p>Convert the value to a string representation.</p> <pre><code>toString(): string\n</code></pre>"},{"location":"api/typescript.html#data","title":"data()","text":"<p>Get the binary representation of the value.</p> <pre><code>data(): Buffer\n</code></pre>"},{"location":"api/typescript.html#size","title":"size()","text":"<p>Get the size of the data in bytes.</p> <pre><code>size(): number\n</code></pre>"},{"location":"api/typescript.html#copy","title":"copy()","text":"<p>Create a deep copy of this instance.</p> <pre><code>copy(): string_t\n</code></pre>"},{"location":"api/typescript.html#key","title":"key()","text":"<p>Get a key representation for equality comparison.</p> <pre><code>key(): string\n</code></pre> <p>Example:</p> <pre><code>const str1 = new string_t(\"hello\");\nconst str2 = new string_t(str1.data());\nconsole.log(str1.toString());  // \"hello\"\n</code></pre>"},{"location":"api/typescript.html#variable_t","title":"variable_t","text":"<p>Wrapper class for logical variables in the deductive system.</p>"},{"location":"api/typescript.html#constructor_1","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | variable_t, size?: number)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string starting with backtick, buffer, or another variable_t)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/typescript.html#methods_1","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#name","title":"name()","text":"<p>Get the name of this variable (without the backtick prefix).</p> <pre><code>name(): string_t\n</code></pre> <p>Example:</p> <pre><code>const var1 = new variable_t(\"`X\");\nconsole.log(var1.name().toString());  // \"X\"\nconsole.log(var1.toString());         // \"`X\"\n</code></pre>"},{"location":"api/typescript.html#item_t","title":"item_t","text":"<p>Wrapper class for items (constants/functors) in the deductive system.</p>"},{"location":"api/typescript.html#constructor_2","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | item_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_2","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#name_1","title":"name()","text":"<p>Get the name of this item.</p> <pre><code>name(): string_t\n</code></pre> <p>Example:</p> <pre><code>const item = new item_t(\"atom\");\nconsole.log(item.name().toString());  // \"atom\"\n</code></pre>"},{"location":"api/typescript.html#list_t","title":"list_t","text":"<p>Wrapper class for lists in the deductive system.</p>"},{"location":"api/typescript.html#constructor_3","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | list_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_3","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#length","title":"length()","text":"<p>Get the number of elements in the list.</p> <pre><code>length(): number\n</code></pre>"},{"location":"api/typescript.html#getitem","title":"getitem()","text":"<p>Get an element from the list by index.</p> <pre><code>getitem(index: number): term_t\n</code></pre> <p>Example:</p> <pre><code>const list = new list_t(\"(a b c)\");\nconsole.log(list.length());           // 3\nconsole.log(list.getitem(0).toString());  // \"a\"\n</code></pre>"},{"location":"api/typescript.html#term_t","title":"term_t","text":"<p>Wrapper class for logical terms in the deductive system. A term can be a variable, item, or list.</p>"},{"location":"api/typescript.html#constructor_4","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | term_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_4","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#term","title":"term()","text":"<p>Extracts the underlying term and returns it as its concrete type.</p> <pre><code>term(): variable_t | item_t | list_t\n</code></pre>"},{"location":"api/typescript.html#ground","title":"ground()","text":"<p>Ground this term using a dictionary to substitute variables with values.</p> <pre><code>ground(other: term_t, scope?: string): term_t | null\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: A term representing a dictionary (list of pairs)</li> <li><code>scope</code> (optional): Scope string for variable scoping</li> </ul> <p>Returns: The grounded term, or null if grounding fails.</p> <p>Example:</p> <pre><code>const a = new term_t(\"`a\");\nconst dict = new term_t(\"((`a b))\");\nconst result = a.ground(dict);\nif (result !== null) {\n    console.log(result.toString());  // \"b\"\n}\n</code></pre>"},{"location":"api/typescript.html#rename","title":"rename()","text":"<p>Rename all variables in this term by adding prefix and suffix.</p> <pre><code>rename(prefix_and_suffix: term_t): term_t | null\n</code></pre> <p>Parameters:</p> <ul> <li><code>prefix_and_suffix</code>: A term with format <code>((prefix) (suffix))</code></li> </ul> <p>Returns: The renamed term, or null if renaming fails.</p> <p>Example:</p> <pre><code>const term = new term_t(\"`x\");\nconst spec = new term_t(\"((pre_) (_suf))\");\nconst result = term.rename(spec);\nif (result !== null) {\n    console.log(result.toString());  // \"`pre_x_suf\"\n}\n</code></pre>"},{"location":"api/typescript.html#rule_t","title":"rule_t","text":"<p>Wrapper class for logical rules in the deductive system.</p>"},{"location":"api/typescript.html#constructor_5","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | rule_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_5","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#length_1","title":"length()","text":"<p>Get the number of premises in the rule.</p> <pre><code>length(): number\n</code></pre>"},{"location":"api/typescript.html#getitem_1","title":"getitem()","text":"<p>Get a premise term by index.</p> <pre><code>getitem(index: number): term_t\n</code></pre>"},{"location":"api/typescript.html#conclusion","title":"conclusion()","text":"<p>Get the conclusion of the rule.</p> <pre><code>conclusion(): term_t\n</code></pre>"},{"location":"api/typescript.html#ground_1","title":"ground()","text":"<p>Ground this rule using a dictionary.</p> <pre><code>ground(other: rule_t, scope?: string): rule_t | null\n</code></pre>"},{"location":"api/typescript.html#match","title":"match()","text":"<p>Match this rule with another rule using unification.</p> <pre><code>match(other: rule_t): rule_t | null\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: The rule to match against (must be a fact without premises)</li> </ul> <p>Returns: The matched rule, or null if matching fails.</p> <p>Example:</p> <pre><code>const mp = new rule_t(\"(`p -&gt; `q)\\n`p\\n`q\\n\");\nconst pq = new rule_t(\"((! (! `x)) -&gt; `x)\");\nconst result = mp.match(pq);\nif (result !== null) {\n    console.log(result.toString());\n    // \"(! (! `x))\\n----------\\n`x\\n\"\n}\n</code></pre>"},{"location":"api/typescript.html#rename_1","title":"rename()","text":"<p>Rename all variables in this rule.</p> <pre><code>rename(prefix_and_suffix: rule_t): rule_t | null\n</code></pre>"},{"location":"api/typescript.html#search_t","title":"search_t","text":"<p>Search engine for the deductive system.</p>"},{"location":"api/typescript.html#constructor_6","title":"Constructor","text":"<pre><code>constructor(limit_size?: number, buffer_size?: number)\n</code></pre> <p>Parameters:</p> <ul> <li><code>limit_size</code> (optional): Size of the buffer for storing rules/facts (default: 1000)</li> <li><code>buffer_size</code> (optional): Size of the buffer for internal operations (default: 10000)</li> </ul>"},{"location":"api/typescript.html#methods_6","title":"Methods","text":""},{"location":"api/typescript.html#set_limit_size","title":"set_limit_size()","text":"<p>Set the size of the buffer for storing final objects.</p> <pre><code>set_limit_size(limit_size: number): void\n</code></pre>"},{"location":"api/typescript.html#set_buffer_size","title":"set_buffer_size()","text":"<p>Set the buffer size for internal operations.</p> <pre><code>set_buffer_size(buffer_size: number): void\n</code></pre>"},{"location":"api/typescript.html#reset","title":"reset()","text":"<p>Reset the search engine, clearing all rules and facts.</p> <pre><code>reset(): void\n</code></pre>"},{"location":"api/typescript.html#add","title":"add()","text":"<p>Add a rule or fact to the knowledge base.</p> <pre><code>add(text: string): boolean\n</code></pre> <p>Returns: True if successfully added, false otherwise.</p>"},{"location":"api/typescript.html#execute","title":"execute()","text":"<p>Execute the search engine with a callback for each inferred rule.</p> <pre><code>execute(callback: (candidate: rule_t) =&gt; boolean): number\n</code></pre> <p>Parameters:</p> <ul> <li><code>callback</code>: Function called for each candidate rule. Return false to continue, true to stop.</li> </ul> <p>Returns: The number of rules processed.</p> <p>Example:</p> <pre><code>const search = new search_t(1000, 10000);\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\nsearch.add(\"(! (! X))\");\n\nsearch.execute((candidate) =&gt; {\n    console.log(candidate.toString());\n    return false;  // Continue searching\n});\n</code></pre>"},{"location":"api/typescript.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating most of the TypeScript API:</p> <pre><code>import { \n    buffer_size, \n    string_t, \n    variable_t, \n    item_t, \n    list_t, \n    term_t, \n    rule_t, \n    search_t \n} from \"atsds\";\n\n// Configure buffer size\nbuffer_size(2048);\n\n// Create terms\nconst varX = new variable_t(\"`X\");\nconst item = new item_t(\"hello\");\nconst lst = new list_t(\"(a b c)\");\nconst term = new term_t(\"(f `x `y)\");\n\nconsole.log(`Variable: ${varX.toString()}, name: ${varX.name().toString()}`);\nconsole.log(`Item: ${item.toString()}, name: ${item.name().toString()}`);\nconsole.log(`List: ${lst.toString()}, length: ${lst.length()}`);\nconsole.log(`Term: ${term.toString()}`);\n\n// Work with rules\nconst fact = new rule_t(\"(parent john mary)\");\nconst rule = new rule_t(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\n\nconsole.log(`\\nFact: ${fact.toString()}`);\nconsole.log(`Rule premises: ${rule.length()}, conclusion: ${rule.conclusion().toString()}`);\n\n// Grounding\nconst termA = new term_t(\"`a\");\nconst dictionary = new term_t(\"((`a hello))\");\nconst grounded = termA.ground(dictionary);\nif (grounded) {\n    console.log(`\\nGrounding \\`a with ((\\`a hello)): ${grounded.toString()}`);\n}\n\n// Matching\nconst mp = new rule_t(\"(`p -&gt; `q)\\n`p\\n`q\\n\");\nconst axiom = new rule_t(\"((A) -&gt; B)\");\nconst matched = mp.match(axiom);\nif (matched) {\n    console.log(`\\nMatching modus ponens with (A -&gt; B):\\n${matched.toString()}`);\n}\n\n// Search engine\nconst search = new search_t(1000, 10000);\nsearch.add(\"p q\");  // p implies q\nsearch.add(\"q r\");  // q implies r\nsearch.add(\"p\");    // fact: p\n\nconsole.log(\"\\nRunning inference:\");\nfor (let i = 0; i &lt; 3; i++) {\n    const count = search.execute((r) =&gt; {\n        console.log(`  Derived: ${r.toString()}`);\n        return false;\n    });\n    if (count === 0) break;\n}\n\n// Copying and comparison\nconst rule1 = new rule_t(\"(a b c)\");\nconst rule2 = rule1.copy();\nconsole.log(`\\nRule comparison: ${rule1.key() === rule2.key()}`);  // true\n</code></pre>"},{"location":"concepts/rules.html","title":"Rules","text":"<p>Rules are the core mechanism for representing logical inference in DS. This page explains how rules work and how to use them.</p>"},{"location":"concepts/rules.html#rule-structure","title":"Rule Structure","text":"<p>A rule consists of:</p> <ul> <li>Premises: Zero or more conditions (above the line)</li> <li>Conclusion: The result when all premises are satisfied (below the line)</li> </ul>"},{"location":"concepts/rules.html#text-representation","title":"Text Representation","text":"<p>Rules are written with premises and conclusion separated by dashes (at least four dashes):</p> <pre><code>premise1\npremise2\n----------\nconclusion\n</code></pre> <p>A fact is a rule with no premises:</p> <pre><code>(parent john mary)\n</code></pre> <p>Or explicitly:</p> <pre><code>----------\n(parent john mary)\n</code></pre> <p>Rule Format Details</p> <ul> <li>Premises are separated by newlines</li> <li>The separator line must contain at least 4 dashes (<code>----</code>) between premises and conclusion</li> <li>Whitespace around premises and conclusion is trimmed</li> <li>A rule without an premises is a fact</li> </ul>"},{"location":"concepts/rules.html#compact-rule-format","title":"Compact Rule Format","text":"<p>For rules with multiple premises, you can use space-separated terms on a single line:</p> <pre><code>(`P -&gt; `Q) `P `Q\n</code></pre> <p>This is equivalent to:</p> <pre><code>(`P -&gt; `Q)\n`P\n----------\n`Q\n</code></pre> <p>The last term is the conclusion, and all preceding terms are premises.</p>"},{"location":"concepts/rules.html#examples","title":"Examples","text":"<p>Modus Ponens (if P implies Q and P is true, then Q is true):</p> <pre><code>(`P -&gt; `Q)\n`P\n----------\n`Q\n</code></pre> <p>Family Relationship (if X is the father of Y, then X is a parent of Y):</p> <pre><code>(father `X `Y)\n----------\n(parent `X `Y)\n</code></pre>"},{"location":"concepts/rules.html#creating-rules","title":"Creating Rules","text":"TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Create a fact\nconst fact = new rule_t(\"(parent john mary)\");\n\n// Create a rule with premises\nconst rule = new rule_t(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\n\n// Access rule components\nconsole.log(`Number of premises: ${rule.length()}`);  // 1\nconsole.log(`First premise: ${rule.getitem(0).toString()}`);  // (father `X `Y)\nconsole.log(`Conclusion: ${rule.conclusion().toString()}`);  // (parent `X `Y)\n</code></pre> <pre><code>import apyds\n\n# Create a fact\nfact = apyds.Rule(\"(parent john mary)\")\n\n# Create a rule with premises\n# Using explicit separator\nrule = apyds.Rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\n\n# Access rule components\nprint(f\"Number of premises: {len(rule)}\")  # 1\nprint(f\"First premise: {rule[0]}\")  # (father `X `Y)\nprint(f\"Conclusion: {rule.conclusion}\")  # (parent `X `Y)\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a fact\n    auto fact = ds::text_to_rule(\"(parent john mary)\", 1000);\n\n    // Create a rule with premises\n    auto rule = ds::text_to_rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\", 1000);\n\n    // Access rule components\n    std::cout &lt;&lt; \"Number of premises: \" &lt;&lt; rule-&gt;premises_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Conclusion: \" &lt;&lt; ds::term_to_text(rule-&gt;conclusion(), 1000).get() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#rule-operations","title":"Rule Operations","text":""},{"location":"concepts/rules.html#grounding","title":"Grounding","text":"<p>Grounding substitutes variables in a rule with values from a dictionary.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Create a rule with variables\nconst rule = new rule_t(\"`a\");\n\n// Create a dictionary\nconst dictionary = new rule_t(\"((`a b))\");\n\n// Ground the rule\nconst result = rule.ground(dictionary);\nif (result !== null) {\n    console.log(result.toString());  // ----\\nb\\n\n}\n</code></pre> <pre><code>import apyds\n\n# Create a rule with variables\nrule = apyds.Rule(\"`a\")\n\n# Create a dictionary\ndictionary = apyds.Rule(\"((`a b))\")\n\n# Ground the rule\nresult = rule.ground(dictionary)\nprint(result)  # ----\\nb\\n\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a rule with variables\n    auto rule = ds::text_to_rule(\"`a\", 1000);\n\n    // Create a dictionary\n    auto dictionary = ds::text_to_rule(\"((`a b))\", 1000);\n\n    // Ground the rule\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::rule_t*&gt;(buffer);\n    result-&gt;ground(rule.get(), dictionary.get(), nullptr, buffer + 1000);\n\n    std::cout &lt;&lt; ds::rule_to_text(result, 1000).get() &lt;&lt; std::endl;  // ----\\nb\\n\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#matching","title":"Matching","text":"<p>Matching unifies the first premise of a rule with a fact, producing a new rule with one fewer premise.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Modus ponens rule\nconst mp = new rule_t(\"(`p -&gt; `q)\\n`p\\n`q\\n\");\n\n// Double negation elimination axiom\nconst axiom = new rule_t(\"((! (! `x)) -&gt; `x)\");\n\n// Match\nconst result = mp.match(axiom);\nif (result !== null) {\n    console.log(result.toString());\n    // (! (! `x))\n    // ----------\n    // `x\n}\n</code></pre> <pre><code>import apyds\n\n# Modus ponens rule: if (P -&gt; Q) and P then Q\nmp = apyds.Rule(\"(`p -&gt; `q)\\n`p\\n`q\\n\")\n\n# A fact: double negation elimination axiom\naxiom = apyds.Rule(\"((! (! `x)) -&gt; `x)\")\n\n# Match: apply axiom to modus ponens\nresult = mp @ axiom  # Uses @ operator\nprint(result)\n# Output:\n# (! (! `x))\n# ----------\n# `x\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Modus ponens rule\n    auto mp = ds::text_to_rule(\"(`p -&gt; `q)\\n`p\\n`q\\n\", 1000);\n\n    // Double negation elimination axiom\n    auto axiom = ds::text_to_rule(\"((! (! `x)) -&gt; `x)\", 1000);\n\n    // Match\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::rule_t*&gt;(buffer);\n    result-&gt;match(mp.get(), axiom.get(), buffer + 1000);\n\n    std::cout &lt;&lt; ds::rule_to_text(result, 1000).get() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#renaming","title":"Renaming","text":"<p>Renaming adds prefixes and/or suffixes to all variables in a rule.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Create a rule\nconst rule = new rule_t(\"`x\");\n\n// Rename with prefix and suffix\nconst spec = new rule_t(\"((pre_) (_suf))\");\nconst result = rule.rename(spec);\nif (result !== null) {\n    console.log(result.toString());  // ----\\n`pre_x_suf\\n\n}\n</code></pre> <pre><code>import apyds\n\n# Create a rule\nrule = apyds.Rule(\"`x\")\n\n# Rename with prefix and suffix\nspec = apyds.Rule(\"((pre_) (_suf))\")\nresult = rule.rename(spec)\nprint(result)  # ----\\n`pre_x_suf\\n\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a rule\n    auto rule = ds::text_to_rule(\"`x\", 1000);\n\n    // Rename with prefix and suffix\n    auto spec = ds::text_to_rule(\"((pre_) (_suf))\", 1000);\n\n    // Rename the rule\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::rule_t*&gt;(buffer);\n    result-&gt;rename(rule.get(), spec.get(), buffer + 1000);\n\n    std::cout &lt;&lt; ds::rule_to_text(result, 1000).get() &lt;&lt; std::endl;  // ----\\n`pre_x_suf\\n\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#rule-comparison","title":"Rule Comparison","text":"<p>Rules can be compared for equality. Two rules are equal if they have the same binary representation.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\nconst rule1 = new rule_t(\"(a b c)\");\nconst rule2 = new rule_t(\"(a b c)\");\nconst rule3 = new rule_t(\"(a b d)\");\n\nconsole.log(rule1.key() === rule2.key());  // true\nconsole.log(rule1.key() === rule3.key());  // false\n</code></pre> <pre><code>import apyds\n\nrule1 = apyds.Rule(\"(a b c)\")\nrule2 = apyds.Rule(\"(a b c)\")\nrule3 = apyds.Rule(\"(a b d)\")\n\nprint(rule1 == rule2)  # True\nprint(rule1 == rule3)  # False\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto rule1 = ds::text_to_rule(\"(a b c)\", 1000);\n    auto rule2 = ds::text_to_rule(\"(a b c)\", 1000);\n    auto rule3 = ds::text_to_rule(\"(a b d)\", 1000);\n\n    bool eq12 = rule1-&gt;data_size() == rule2-&gt;data_size() &amp;&amp;\n                memcmp(rule1-&gt;head(), rule2-&gt;head(), rule1-&gt;data_size()) == 0;\n    bool eq13 = rule1-&gt;data_size() == rule3-&gt;data_size() &amp;&amp;\n                memcmp(rule1-&gt;head(), rule3-&gt;head(), rule1-&gt;data_size()) == 0;\n\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; eq12 &lt;&lt; std::endl;  // true\n    std::cout &lt;&lt; eq13 &lt;&lt; std::endl;  // false\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#see-also","title":"See Also","text":"<ul> <li>Terms - Building blocks for rules</li> <li>Search Engine - Performing inference with rules</li> </ul>"},{"location":"concepts/search.html","title":"Search Engine","text":"<p>The search engine is the core inference mechanism in DS. It manages a knowledge base of rules and facts, and performs logical inference by matching rules with facts.</p>"},{"location":"concepts/search.html#overview","title":"Overview","text":"<p>The search engine:</p> <ol> <li>Maintains a collection of rules and facts</li> <li>Iteratively applies rules to generate new facts</li> <li>Notifies you of each new inference via a callback</li> <li>Automatically prevents duplicate inferences</li> </ol> <p>How It Works</p> <p>The search engine uses a forward-chaining inference approach:</p> <ol> <li>When you call <code>execute()</code>, the engine tries to match the first premise of each rule with existing facts</li> <li>When a match is found, variables in the rule are substituted and a new rule (with one fewer premise) is created</li> <li>If the new rule has no premises, it becomes a new fact</li> <li>The callback is invoked for each newly derived rule</li> <li>Duplicate rules are automatically filtered out</li> </ol>"},{"location":"concepts/search.html#creating-a-search-engine","title":"Creating a Search Engine","text":"PythonTypeScriptC++ <pre><code>import apyds\n\n# Create with default sizes\nsearch = apyds.Search()\n\n# Create with custom sizes\nsearch = apyds.Search(limit_size=1000, buffer_size=10000)\n</code></pre> <pre><code>import { search_t } from \"atsds\";\n\n// Create with default sizes\nconst search = new search_t();\n\n// Create with custom sizes\nconst search2 = new search_t(1000, 10000);\n</code></pre> <pre><code>#include &lt;ds/search.hh&gt;\n\n// Create search engine\nds::search_t search(1000, 10000);\n</code></pre>"},{"location":"concepts/search.html#parameters","title":"Parameters","text":"<ul> <li>limit_size: Maximum size (in bytes) for each stored rule/fact (default: 1000). Rules or facts larger than this are rejected.</li> <li>buffer_size: Size of the internal buffer for intermediate operations (default: 10000). Increase this if you work with complex rules.</li> </ul>"},{"location":"concepts/search.html#adding-rules-and-facts","title":"Adding Rules and Facts","text":"<p>Use the <code>add()</code> method to add rules and facts to the knowledge base.</p> PythonTypeScriptC++ <pre><code>import apyds\n\nsearch = apyds.Search()\n\n# Add a fact\nsearch.add(\"(parent john mary)\")\n\n# Add a rule with premises\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\n</code></pre> <pre><code>import { search_t } from \"atsds\";\n\nconst search = new search_t();\n\n// Add a fact\nsearch.add(\"(parent john mary)\");\n\n// Add a rule with premises\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\n</code></pre> <pre><code>ds::search_t search(1000, 10000);\n\n// Add a fact\nsearch.add(\"(parent john mary)\");\n\n// Add a rule\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\n</code></pre>"},{"location":"concepts/search.html#executing-search","title":"Executing Search","text":"<p>The <code>execute()</code> method performs one round of inference. It matches all rules against all facts and generates new conclusions.</p> PythonTypeScriptC++ <pre><code>import apyds\n\nsearch = apyds.Search()\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\nsearch.add(\"(father john mary)\")\n\ndef callback(rule):\n    print(f\"Found: {rule}\")\n    return False  # Continue searching\n\n# Execute one round\ncount = search.execute(callback)\nprint(f\"Generated {count} new facts\")\n</code></pre> <pre><code>import { search_t } from \"atsds\";\n\nconst search = new search_t();\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\nsearch.add(\"(father john mary)\");\n\nconst count = search.execute((rule) =&gt; {\n    console.log(`Found: ${rule.toString()}`);\n    return false;  // Continue searching\n});\n\nconsole.log(`Generated ${count} new facts`);\n</code></pre> <pre><code>ds::search_t search(1000, 10000);\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\nsearch.add(\"(father john mary)\");\n\nauto count = search.execute([](ds::rule_t* rule) {\n    printf(\"Found: %s\\n\", ds::rule_to_text(rule, 1000).get());\n    return false;  // Continue searching\n});\n\nprintf(\"Generated %lu new facts\\n\", count);\n</code></pre>"},{"location":"concepts/search.html#callback-function","title":"Callback Function","text":"<p>The callback receives each newly inferred rule and should return:</p> <ul> <li><code>False</code> (Python) / <code>false</code> (TypeScript/C++): Continue searching</li> <li><code>True</code> (Python) / <code>true</code> (TypeScript/C++): Stop searching</li> </ul>"},{"location":"concepts/search.html#searching-for-a-target","title":"Searching for a Target","text":"<p>To search until a specific target is found:</p> PythonTypeScript <pre><code>import apyds\n\nsearch = apyds.Search(1000, 10000)\n\n# Set up propositional logic\nsearch.add(\"(`P -&gt; `Q) `P `Q\")  # Modus ponens\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\")  # Axiom 1\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\")  # Axiom 2\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\")  # Axiom 3\nsearch.add(\"(! (! X))\")  # Premise\n\ntarget = apyds.Rule(\"X\")\n\nwhile True:\n    found = False\n    def check(candidate):\n        nonlocal found\n        if candidate == target:\n            print(f\"Found: {candidate}\")\n            found = True\n            return True\n        return False\n    search.execute(check)\n    if found:\n        break\n</code></pre> <pre><code>import { rule_t, search_t } from \"atsds\";\n\nconst search = new search_t(1000, 10000);\n\n// Set up propositional logic\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\");\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\nsearch.add(\"(! (! X))\");\n\nconst target = new rule_t(\"X\");\n\nwhile (true) {\n    let found = false;\n    search.execute((candidate) =&gt; {\n        if (candidate.key() === target.key()) {\n            console.log(\"Found:\", candidate.toString());\n            found = true;\n            return true;\n        }\n        return false;\n    });\n    if (found) break;\n}\n</code></pre>"},{"location":"concepts/search.html#configuration-methods","title":"Configuration Methods","text":""},{"location":"concepts/search.html#set-limit-size","title":"Set Limit Size","text":"<p>Controls the maximum size for each stored rule/fact:</p> PythonTypeScriptC++ <pre><code>search.set_limit_size(2000)\n</code></pre> <pre><code>search.set_limit_size(2000);\n</code></pre> <pre><code>search.set_limit_size(2000);\n</code></pre>"},{"location":"concepts/search.html#set-buffer-size","title":"Set Buffer Size","text":"<p>Controls the internal buffer size for operations:</p> PythonTypeScriptC++ <pre><code>search.set_buffer_size(20000)\n</code></pre> <pre><code>search.set_buffer_size(20000);\n</code></pre> <pre><code>search.set_buffer_size(20000);\n</code></pre>"},{"location":"concepts/search.html#reset","title":"Reset","text":"<p>Clears all rules and facts:</p> PythonTypeScriptC++ <pre><code>search.reset()\n</code></pre> <pre><code>search.reset();\n</code></pre> <pre><code>search.reset();\n</code></pre>"},{"location":"concepts/search.html#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Buffer Size: Larger buffers allow more complex intermediate results but use more memory</li> <li>Limit Size: Restricts maximum rule/fact complexity - too small may reject valid rules</li> <li>Iterative Execution: Call <code>execute()</code> in a loop to continue inference until convergence</li> <li>Early Termination: Return <code>true</code> from callback to stop as soon as target is found</li> <li>Deduplication: The engine automatically deduplicates facts, avoiding redundant computation</li> </ol>"},{"location":"concepts/search.html#see-also","title":"See Also","text":"<ul> <li>Terms - Building blocks for the search</li> <li>Rules - How rules are structured and matched</li> </ul>"},{"location":"concepts/terms.html","title":"Terms","text":"<p>Terms are the fundamental building blocks of the deductive system. This page explains the different types of terms and how to work with them.</p>"},{"location":"concepts/terms.html#term-types","title":"Term Types","text":"<p>The deductive system supports three basic types of terms:</p>"},{"location":"concepts/terms.html#variables","title":"Variables","text":"<p>Variables are placeholders that can be unified with other terms during inference. They are prefixed with a backtick (<code>`</code>).</p> <pre><code>`X\n`variable_name\n`P\n`Q\n</code></pre> <p>Variables are used in rules to represent any term that can match during unification. During the inference process, variables can be bound to specific terms through unification.</p> <p>Variable Naming</p> <p>Variable names can contain any characters except backtick, whitespace and parentheses. By convention, single uppercase letters like <code>`X</code>, <code>`P</code>, <code>`Q</code> are often used for simple logic, while descriptive names like <code>`person</code> or <code>`result</code> improve readability in complex rules.</p>"},{"location":"concepts/terms.html#items","title":"Items","text":"<p>Items represent constants or functors. They are atomic values without any special prefix.</p> <pre><code>hello\natom\nfather\n!\n-&gt;\n</code></pre> <p>Items can represent:</p> <ul> <li>Constants: Atomic values like <code>john</code>, <code>mary</code>, <code>42</code></li> <li>Functors: Symbols that combine other terms, like <code>father</code>, <code>-&gt;</code>, <code>!</code></li> <li>Operators: Special symbols used in logical expressions, like <code>-&gt;</code> for implication or <code>!</code> for negation</li> </ul> <p>Item Characters</p> <p>Items can contain any characters except backtick, whitespace and parentheses. Special symbols like <code>-&gt;</code>, <code>!</code>, <code>&lt;-</code>, <code>&amp;&amp;</code>, <code>||</code> are commonly used as logical operators.</p>"},{"location":"concepts/terms.html#lists","title":"Lists","text":"<p>Lists are ordered sequences of terms enclosed in parentheses. They can contain any combination of variables, items, and nested lists.</p> <pre><code>(a b c)\n(father john mary)\n(-&gt; P Q)\n(! (! X))\n</code></pre> <p>Lists are the primary way to build complex structures in the deductive system. They can represent:</p> <ul> <li>Relations: <code>(father john mary)</code> - \"John is the father of Mary\"</li> <li>Logical expressions: <code>(P -&gt; Q)</code> - \"P implies Q\"</li> <li>Nested structures: <code>(! (! X))</code> - \"not not X\" (double negation)</li> <li>Data collections: <code>(1 2 3 4 5)</code> - a list of numbers</li> </ul> <p>List Nesting</p> <p>Lists can be nested to any depth: <pre><code>((a b) (c d) (e f))\n(if (&gt; `x 0) (positive `x) (non-positive `x))\n</code></pre></p>"},{"location":"concepts/terms.html#creating-terms","title":"Creating Terms","text":"TypeScriptPythonC++ <pre><code>import { variable_t, item_t, list_t, term_t } from \"atsds\";\n\n// Create a variable\nconst var1 = new variable_t(\"`X\");\nconsole.log(`Variable name: ${var1.name().toString()}`);  // X\n\n// Create an item\nconst item = new item_t(\"hello\");\nconsole.log(`Item name: ${item.name().toString()}`);  // hello\n\n// Create a list\nconst lst = new list_t(\"(a b c)\");\nconsole.log(`List length: ${lst.length()}`);  // 3\nconsole.log(`First element: ${lst.getitem(0).toString()}`);  // a\n\n// Create a generic term\nconst term = new term_t(\"(f `x)\");\n// Access the underlying type\nconst inner = term.term();  // Returns a list_t\n</code></pre> <pre><code>import apyds\n\n# Create a variable\nvar = apyds.Variable(\"`X\")\nprint(f\"Variable name: {var.name}\")  # X\n\n# Create an item\nitem = apyds.Item(\"hello\")\nprint(f\"Item name: {item.name}\")  # hello\n\n# Create a list\nlst = apyds.List(\"(a b c)\")\nprint(f\"List length: {len(lst)}\")  # 3\nprint(f\"First element: {lst[0]}\")  # a\n\n# Create a generic term\nterm = apyds.Term(\"(f `x)\")\n# Access the underlying type\ninner = term.term  # Returns a List\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a generic term\n    auto term = ds::text_to_term(\"(f `x)\", 1000);\n    // Access the underlying type\n    auto list = term-&gt;list();\n    auto item = list-&gt;term(0)-&gt;item();\n    auto variable = list-&gt;term(1)-&gt;variable();\n    return 0;\n}\n</code></pre>"},{"location":"concepts/terms.html#term-operations","title":"Term Operations","text":""},{"location":"concepts/terms.html#grounding","title":"Grounding","text":"<p>Grounding substitutes variables in a term with values from a dictionary. The dictionary is a list of key-value pairs where each key is a variable and each value is its substitution.</p> TypeScriptPythonC++ <pre><code>import { term_t } from \"atsds\";\n\n// Create a term with a variable\nconst term = new term_t(\"`a\");\n\n// Create a dictionary for substitution\nconst dictionary = new term_t(\"((`a b))\");\n\n// Ground the term\nconst result = term.ground(dictionary);\nif (result !== null) {\n    console.log(result.toString());  // b\n}\n</code></pre> <pre><code>import apyds\n\n# Create a term with a variable\nterm = apyds.Term(\"`a\")\n\n# Create a dictionary for substitution\n# Format: ((variable value) ...)\ndictionary = apyds.Term(\"((`a b))\")\n\n# Ground the term\nresult = term.ground(dictionary)\nprint(result)  # b\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a term with a variable\n    auto term = ds::text_to_term(\"`a\", 1000);\n\n    // Create a dictionary for substitution\n    auto dictionary = ds::text_to_term(\"((`a b))\", 1000);\n\n    // Ground the term\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::term_t*&gt;(buffer);\n    result-&gt;ground(term.get(), dictionary.get(), nullptr, buffer + 1000);\n\n    std::cout &lt;&lt; ds::term_to_text(result, 1000).get() &lt;&lt; std::endl;  // b\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/terms.html#renaming","title":"Renaming","text":"<p>Renaming adds prefixes and/or suffixes to all variables in a term. This is useful for avoiding variable name collisions during unification.</p> TypeScriptPythonC++ <pre><code>import { term_t } from \"atsds\";\n\n// Create a term with a variable\nconst term = new term_t(\"`x\");\n\n// Create prefix and suffix specification\nconst spec = new term_t(\"((pre_) (_suf))\");\n\n// Rename the term\nconst result = term.rename(spec);\nif (result !== null) {\n    console.log(result.toString());  // `pre_x_suf\n}\n</code></pre> <pre><code>import apyds\n\n# Create a term with a variable\nterm = apyds.Term(\"`x\")\n\n# Create prefix and suffix specification\n# Format: ((prefix) (suffix))\nspec = apyds.Term(\"((pre_) (_suf))\")\n\n# Rename the term\nresult = term.rename(spec)\nprint(result)  # `pre_x_suf\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a term with a variable\n    auto term = ds::text_to_term(\"`x\", 1000);\n\n    // Create prefix and suffix specification\n    auto spec = ds::text_to_term(\"((pre_) (_suf))\", 1000);\n\n    // Rename the term\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::term_t*&gt;(buffer);\n    result-&gt;rename(term.get(), spec.get(), buffer + 1000);\n\n    std::cout &lt;&lt; ds::term_to_text(result, 1000).get() &lt;&lt; std::endl;  // `pre_x_suf\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/terms.html#buffer-size","title":"Buffer Size","text":"<p>Operations like grounding and renaming require buffer space for intermediate results in TypeScript/Javascript and Python. You can control this using buffer size functions.</p> TypeScriptPython <pre><code>import { buffer_size } from \"atsds\";\n\n// Get current buffer size\nconst current = buffer_size();\n\n// Set new buffer size (returns previous value)\nconst old = buffer_size(4096);\n</code></pre> <pre><code>import apyds\n\n# Get current buffer size\ncurrent = apyds.buffer_size()\n\n# Set new buffer size (returns previous value)\nold = apyds.buffer_size(4096)\n\n# Use context manager for temporary change\nwith apyds.scoped_buffer_size(8192):\n    # Operations here use buffer size of 8192\n    pass\n# Buffer size restored to previous value\n</code></pre>"},{"location":"concepts/terms.html#see-also","title":"See Also","text":"<ul> <li>Rules - How to create and work with inference rules</li> <li>Search Engine - Performing logical inference</li> </ul>"},{"location":"examples/basic.html","title":"Basic Examples","text":"<p>This section contains examples demonstrating the DS deductive system in various languages.</p>"},{"location":"examples/basic.html#propositional-logic-inference","title":"Propositional Logic Inference","text":"<p>The classic example demonstrates double negation elimination using propositional logic axioms:</p> <ul> <li>Modus Ponens: If P implies Q, and P is true, then Q is true</li> <li>Axiom 1: P \u2192 (Q \u2192 P)</li> <li>Axiom 2: (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))</li> <li>Axiom 3: (\u00acP \u2192 \u00acQ) \u2192 (Q \u2192 P)</li> </ul> <p>Given the premise \u00ac\u00acX (double negation of X), we can derive X.</p> PythonTypeScriptC++ <pre><code>import apyds\n\n# Create a search engine\nsearch = apyds.Search(1000, 10000)\n\n# Modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\")\n# Axiom schema 1: p -&gt; (q -&gt; p)\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\")\n# Axiom schema 2: (p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r))\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\")\n# Axiom schema 3: (!p -&gt; !q) -&gt; (q -&gt; p)\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\")\n\n# Premise: !!X\nsearch.add(\"(! (! X))\")\n\n# Target: X (double negation elimination)\ntarget = apyds.Rule(\"X\")\n\n# Execute search until target is found\nwhile True:\n    found = False\n    def callback(candidate):\n        nonlocal found\n        if candidate == target:\n            print(\"Found:\", candidate)\n            found = True\n            return True  # Stop search\n        return False  # Continue searching\n    search.execute(callback)\n    if found:\n        break\n</code></pre> <pre><code>import { rule_t, search_t } from \"atsds\";\n\n// Create a search engine\nconst search = new search_t(1000, 10000);\n\n// Modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\n// Axiom schema 1: p -&gt; (q -&gt; p)\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\");\n// Axiom schema 2: (p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r))\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\n// Axiom schema 3: (!p -&gt; !q) -&gt; (q -&gt; p)\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\n\n// Premise: !!X\nsearch.add(\"(! (! X))\");\n\n// Target: X (double negation elimination)\nconst target = new rule_t(\"X\");\n\n// Execute search until target is found\nwhile (true) {\n    let found = false;\n    search.execute((candidate) =&gt; {\n        if (candidate.key() === target.key()) {\n            console.log(\"Found:\", candidate.toString());\n            found = true;\n            return true; // Stop search\n        }\n        return false; // Continue searching\n    });\n    if (found) break;\n}\n</code></pre> <pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n#include &lt;ds/utility.hh&gt;\n\nint main() {\n    ds::search_t search(1000, 10000);\n\n    // Modus ponens: P -&gt; Q, P |- Q\n    search.add(\"(`P -&gt; `Q) `P `Q\");\n    // Axiom schema 1: p -&gt; (q -&gt; p)\n    search.add(\"(`p -&gt; (`q -&gt; `p))\");\n    // Axiom schema 2: (p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r))\n    search.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\n    // Axiom schema 3: (!p -&gt; !q) -&gt; (q -&gt; p)\n    search.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\n\n    // Premise: !!X\n    search.add(\"(! (! X))\");\n\n    // Target: X (double negation elimination)\n    auto target = ds::text_to_rule(\"X\", 1000);\n\n    // Execute search until target is found\n    while (true) {\n        bool found = false;\n        search.execute([&amp;](ds::rule_t* candidate) {\n            if (candidate-&gt;data_size() == target-&gt;data_size() &amp;&amp;\n                memcmp(candidate-&gt;head(), target-&gt;head(), candidate-&gt;data_size()) == 0) {\n                printf(\"Found: %s\", ds::rule_to_text(candidate, 1000).get());\n                found = true;\n                return true; // Stop search\n            }\n            return false; // Continue searching\n        });\n        if (found) break;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/basic.html#running-the-examples","title":"Running the Examples","text":"<p>Example files are provided in the repository under <code>examples/</code>:</p> <ul> <li><code>examples/main.py</code> - Python example</li> <li><code>examples/main.mjs</code> - TypeScript/JavaScript example</li> <li><code>examples/main.cc</code> - C++ example</li> </ul>"},{"location":"examples/basic.html#python","title":"Python","text":"<pre><code>pip install apyds\npython examples/main.py\n</code></pre>"},{"location":"examples/basic.html#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>npm install atsds\nnode examples/main.mjs\n</code></pre>"},{"location":"examples/basic.html#c","title":"C++","text":"<pre><code>cmake -B build\ncmake --build build\n./build/main\n</code></pre>"},{"location":"examples/sudoku.html","title":"Sudoku","text":"<p>This example demonstrates a Sudoku Solver powered by the DS deductive system. The solver uses logical rules to deduce cell values based on standard Sudoku constraints:</p> <ul> <li>Row constraint: Each row must contain the digits 1-9 exactly once</li> <li>Column constraint: Each column must contain the digits 1-9 exactly once</li> <li>Box constraint: Each 3\u00d73 box must contain the digits 1-9 exactly once</li> </ul>"},{"location":"examples/sudoku.html#how-it-works","title":"How It Works","text":"<p>The Sudoku solver encodes Sudoku rules as logical inference rules in the DS system. When you click \"Solve\", the search engine iteratively applies these rules to deduce new cell values until the puzzle is complete. You can also click \"Update\" to perform a single iteration of inference and observe the step-by-step solving process in the log.</p>"},{"location":"examples/sudoku.html#interactive-demo","title":"Interactive Demo","text":"<p>     Loading Sudoku Solver...   </p>"},{"location":"getting-started/installation.html","title":"Installation","text":"<p>DS can be installed for TypeScript/JavaScript, Python, or used directly as a C++ library.</p>"},{"location":"getting-started/installation.html#typescriptjavascript","title":"TypeScript/JavaScript","text":"<p>The TypeScript/JavaScript package <code>atsds</code> wraps the C++ core via WebAssembly.</p> <pre><code>npm install atsds\n</code></pre> <p>The package includes:</p> <ul> <li>WebAssembly binaries (<code>.wasm</code>)</li> <li>TypeScript type definitions (<code>.d.mts</code>)</li> <li>ES module support</li> </ul>"},{"location":"getting-started/installation.html#requirements","title":"Requirements","text":"<ul> <li>Node.js 20+ or a modern browser with WebAssembly support</li> </ul>"},{"location":"getting-started/installation.html#browser-usage","title":"Browser Usage","text":"<p>The package works in browsers that support WebAssembly:</p> <pre><code>&lt;script type=\"module\"&gt;\n  import { term_t } from \"https://unpkg.com/atsds/dist/tsds.mjs\";\n\n  const term = new term_t(\"(hello world)\");\n  console.log(term.toString());\n&lt;/script&gt;\n</code></pre>"},{"location":"getting-started/installation.html#python","title":"Python","text":"<p>The Python package <code>apyds</code> wraps the C++ core via pybind11.</p> <pre><code>pip install apyds\n</code></pre>"},{"location":"getting-started/installation.html#requirements_1","title":"Requirements","text":"<ul> <li>Python 3.10-3.14</li> <li>Pre-built wheels are available for common platforms (Linux, macOS, Windows)</li> </ul>"},{"location":"getting-started/installation.html#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>It's recommended to use a virtual environment:</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install apyds\n</code></pre>"},{"location":"getting-started/installation.html#development-installation","title":"Development Installation","text":"<p>To install from source with development dependencies:</p> <pre><code>git clone https://github.com/USTC-KnowledgeComputingLab/ds.git\ncd ds\nuv sync --extra dev\n</code></pre>"},{"location":"getting-started/installation.html#c","title":"C++","text":"<p>The C++ library is the core implementation. Both Python and TypeScript bindings are built on top of it.</p>"},{"location":"getting-started/installation.html#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 compatible compiler (GCC 10+, Clang 10+, MSVC 2019+)</li> <li>CMake 3.30+</li> </ul>"},{"location":"getting-started/installation.html#building-from-source","title":"Building from Source","text":"<pre><code>git clone https://github.com/USTC-KnowledgeComputingLab/ds.git\ncd ds\ncmake -B build\ncmake --build build\n</code></pre>"},{"location":"getting-started/installation.html#using-in-your-project","title":"Using in Your Project","text":"<p>Include the headers from <code>include/ds/</code> in your C++ project:</p> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n</code></pre> <p>Link against the <code>ds</code> static library produced by the build.</p>"},{"location":"getting-started/installation.html#building-all-components","title":"Building All Components","text":"<p>To build all language bindings from source:</p>"},{"location":"getting-started/installation.html#typescriptjavascript-requires-emscripten","title":"TypeScript/JavaScript (requires Emscripten)","text":"<pre><code># Install Emscripten SDK first\n# https://emscripten.org/docs/getting_started/downloads.html\n\nnpm install\nnpm run build\n</code></pre>"},{"location":"getting-started/installation.html#python_1","title":"Python","text":"<pre><code>uv sync --extra dev\n</code></pre>"},{"location":"getting-started/installation.html#c_1","title":"C++","text":"<pre><code>cmake -B build\ncmake --build build\n</code></pre>"},{"location":"getting-started/installation.html#running-tests","title":"Running Tests","text":"<p>After installation, you can verify everything works by running the tests:</p>"},{"location":"getting-started/installation.html#typescriptjavascript-tests","title":"TypeScript/JavaScript Tests","text":"<pre><code>npm test\n</code></pre>"},{"location":"getting-started/installation.html#python-tests","title":"Python Tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"getting-started/installation.html#c-tests","title":"C++ Tests","text":"<pre><code>cd build\nctest\n</code></pre>"},{"location":"getting-started/installation.html#verifying-installation","title":"Verifying Installation","text":"TypeScriptPythonC++ <pre><code>import { term_t } from \"atsds\";\n\nconst term = new term_t(\"(hello world)\");\nconsole.log(term.toString());\n// Output: (hello world)\n</code></pre> <pre><code>import apyds\nprint(f\"Version: {apyds.__version__}\")\n\nterm = apyds.Term(\"(hello world)\")\nprint(term)  # (hello world)\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto term = ds::text_to_term(\"(hello world)\", 1000);\n    std::cout &lt;&lt; ds::term_to_text(term.get(), 1000).get() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html","title":"Quick Start","text":"<p>This guide will help you get started with DS in your preferred language.</p>"},{"location":"getting-started/quickstart.html#creating-terms","title":"Creating Terms","text":"<p>Terms are the basic building blocks of the deductive system. A term can be:</p> <ul> <li>Variable: Prefixed with backtick, e.g., <code>`X</code>, <code>`P</code></li> <li>Item: Constants or functors, e.g., <code>a</code>, <code>father</code>, <code>!</code></li> <li>List: Ordered sequences in parentheses, e.g., <code>(a b c)</code></li> </ul> PythonTypeScriptC++ <pre><code>import apyds\n\n# Create different types of terms\nvar = apyds.Variable(\"`X\")\nitem = apyds.Item(\"hello\")\nlst = apyds.List(\"(a b c)\")\nterm = apyds.Term(\"(f `x a)\")\n\nprint(f\"Variable: {var}\")      # `X\nprint(f\"Item: {item}\")         # hello\nprint(f\"List: {lst}\")          # (a b c)\nprint(f\"Term: {term}\")         # (f `x a)\n</code></pre> <pre><code>import { variable_t, item_t, list_t, term_t } from \"atsds\";\n\n// Create different types of terms\nconst var1 = new variable_t(\"`X\");\nconst item = new item_t(\"hello\");\nconst lst = new list_t(\"(a b c)\");\nconst term = new term_t(\"(f `x a)\");\n\nconsole.log(`Variable: ${var1.toString()}`);  // `X\nconsole.log(`Item: ${item.toString()}`);      // hello\nconsole.log(`List: ${lst.toString()}`);       // (a b c)\nconsole.log(`Term: ${term.toString()}`);      // (f `x a)\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto term = ds::text_to_term(\"(f `x a)\", 1000);\n    std::cout &lt;&lt; \"Term: \" &lt;&lt; ds::term_to_text(term.get(), 1000).get() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html#creating-rules","title":"Creating Rules","text":"<p>Rules represent logical inference steps. A rule has premises (conditions) and a conclusion.</p> PythonTypeScriptC++ <pre><code>import apyds\n\n# A fact (rule with no premises)\nfact = apyds.Rule(\"(parent john mary)\")\nprint(f\"Fact: {fact}\")\n\n# A rule with premises\n# Format: premise1\\npremise2\\nconclusion\\n\nrule = apyds.Rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\nprint(f\"Rule premises: {len(rule)}\")\nprint(f\"Rule conclusion: {rule.conclusion}\")\n</code></pre> <pre><code>import { rule_t } from \"atsds\";\n\n// A fact (rule with no premises)\nconst fact = new rule_t(\"(parent john mary)\");\nconsole.log(`Fact: ${fact.toString()}`);\n\n// A rule with premises\nconst rule = new rule_t(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\nconsole.log(`Rule premises: ${rule.length()}`);\nconsole.log(`Rule conclusion: ${rule.conclusion().toString()}`);\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto fact = ds::text_to_rule(\"(parent john mary)\", 1000);\n    auto rule = ds::text_to_rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\", 1000);\n\n    std::cout &lt;&lt; \"Rule premises: \" &lt;&lt; rule-&gt;premises_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Rule conclusion: \" &lt;&lt; ds::rule_to_text(fact-&gt;conclusion(), 1000).get() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html#using-the-search-engine","title":"Using the Search Engine","text":"<p>The search engine performs logical inference by matching rules with facts.</p> PythonTypeScriptC++ <pre><code>import apyds\n\n# Create search engine\nsearch = apyds.Search(1000, 10000)\n\n# Add modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\")\n\n# Add axiom schemas\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\")  # Axiom 1\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\")  # Axiom 2\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\")  # Axiom 3\n\n# Add premise: !!X (double negation)\nsearch.add(\"(! (! X))\")\n\n# Define target: X\ntarget = apyds.Rule(\"X\")\n\n# Execute search\nwhile True:\n    found = False\n    def callback(candidate):\n        nonlocal found\n        if candidate == target:\n            print(f\"Found: {candidate}\")\n            found = True\n            return True\n        return False\n    search.execute(callback)\n    if found:\n        break\n</code></pre> <pre><code>import { rule_t, search_t } from \"atsds\";\n\n// Create search engine\nconst search = new search_t(1000, 10000);\n\n// Add modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\n\n// Add axiom schemas\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\");  // Axiom 1\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");  // Axiom 2\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");  // Axiom 3\n\n// Add premise: !!X (double negation)\nsearch.add(\"(! (! X))\");\n\n// Define target: X\nconst target = new rule_t(\"X\");\n\n// Execute search\nwhile (true) {\n    let found = false;\n    search.execute((candidate) =&gt; {\n        if (candidate.key() === target.key()) {\n            console.log(\"Found:\", candidate.toString());\n            found = true;\n            return true;\n        }\n        return false;\n    });\n    if (found) break;\n}\n</code></pre> <pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n#include &lt;ds/utility.hh&gt;\n\nint main() {\n    ds::search_t search(1000, 10000);\n\n    // Add modus ponens: P -&gt; Q, P |- Q\n    search.add(\"(`P -&gt; `Q) `P `Q\");\n\n    // Add axiom schemas\n    search.add(\"(`p -&gt; (`q -&gt; `p))\");\n    search.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\n    search.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\n\n    // Add premise: !!X (double negation)\n    search.add(\"(! (! X))\");\n\n    // Define target: X\n    auto target = ds::text_to_rule(\"X\", 1000);\n\n    // Execute search\n    while (true) {\n        bool found = false;\n        search.execute([&amp;](ds::rule_t* candidate) {\n            if (candidate-&gt;data_size() == target-&gt;data_size() &amp;&amp;\n                memcmp(candidate-&gt;head(), target-&gt;head(), candidate-&gt;data_size()) == 0) {\n                printf(\"Found: %s\", ds::rule_to_text(candidate, 1000).get());\n                found = true;\n                return true;\n            }\n            return false;\n        });\n        if (found) break;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about Terms</li> <li>Understand Rules</li> <li>Explore the Search Engine</li> <li>Check the API Reference</li> </ul>"}]}