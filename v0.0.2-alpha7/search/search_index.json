{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"DS - A Deductive System","text":"<p>A deductive system for logical inference, implemented in C++. The library provides bindings for Python (via pybind11) and TypeScript/JavaScript (via Emscripten/WebAssembly).</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Multi-Language Support: Use the same deductive system in C++, Python, or TypeScript/JavaScript</li> <li>Logical Terms: Work with variables, items (constants/functors), and lists</li> <li>Rule-Based Inference: Define rules and facts, perform logical deduction</li> <li>Unification and Matching: Unify terms and match rules</li> <li>Search Engine: Built-in search mechanism for iterative inference</li> <li>WebAssembly: Run inference in the browser or Node.js environments</li> <li>Type-Safe: Strong typing support in TypeScript and Python</li> </ul>"},{"location":"index.html#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Application Layer                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 TypeScript (atsds) \u2502   Python (apyds)   \u2502    C++ Direct    \u2502\n\u2502   via WebAssembly  \u2502    via pybind11    \u2502                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                       C++ Core Library                     \u2502\n\u2502                     (include/ds/, src/)                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"index.html#quick-links","title":"Quick Links","text":"<ul> <li>Installation - Install DS for your preferred language</li> <li>Quick Start - Get up and running in minutes</li> <li>Core Concepts - Learn about terms, rules, and inference</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"index.html#supported-languages","title":"Supported Languages","text":"PythonTypeScriptC++ <pre><code>import apyds\n\nsearch = apyds.Search(1000, 10000)\nsearch.add(\"(`P -&gt; `Q) `P `Q\")  # Modus ponens\nsearch.add(\"(! (! X))\")  # Premise: !!X\n\ntarget = apyds.Rule(\"X\")\n# ... execute search\n</code></pre> <pre><code>import { rule_t, search_t } from \"atsds\";\n\nconst search = new search_t(1000, 10000);\nsearch.add(\"(`P -&gt; `Q) `P `Q\");  // Modus ponens\nsearch.add(\"(! (! X))\");  // Premise: !!X\n\nconst target = new rule_t(\"X\");\n// ... execute search\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n\nds::search_t search(1000, 10000);\nsearch.add(\"(`P -&gt; `Q) `P `Q\");  // Modus ponens\nsearch.add(\"(! (! X))\");  // Premise: !!X\n\nauto target = ds::text_to_rule(\"X\", 1000);\n// ... execute search\n</code></pre>"},{"location":"index.html#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0 or later.</p>"},{"location":"api/cpp.html","title":"C++ API Reference","text":"<p>This page documents the C++ API for the DS library. The documentation is generated from the C++ source code.</p> <p>All classes and functions are in the <code>ds</code> namespace.</p>"},{"location":"api/cpp.html#headers","title":"Headers","text":"<pre><code>#include &lt;ds/ds.hh&gt;        // All basic types\n#include &lt;ds/search.hh&gt;    // Search engine\n#include &lt;ds/utility.hh&gt;   // Helper functions\n</code></pre>"},{"location":"api/cpp.html#string_t","title":"string_t","text":"<p>String handling class. Defined in <code>&lt;ds/string.hh&gt;</code>.</p>"},{"location":"api/cpp.html#methods","title":"Methods","text":""},{"location":"api/cpp.html#data_size","title":"data_size()","text":"<p>Get the size of the string data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head","title":"head()","text":"<p>Get a pointer to the first byte.</p> <pre><code>std::byte* head();\n</code></pre>"},{"location":"api/cpp.html#tail","title":"tail()","text":"<p>Get a pointer past the last byte.</p> <pre><code>std::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print","title":"print()","text":"<p>Output the string to a buffer.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#scan","title":"scan()","text":"<p>Read a string from a buffer.</p> <pre><code>const char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#variable_t","title":"variable_t","text":"<p>Logical variable class. Defined in <code>&lt;ds/variable.hh&gt;</code>.</p> <p>Variables represent placeholders that can be unified with other terms.</p>"},{"location":"api/cpp.html#methods_1","title":"Methods","text":""},{"location":"api/cpp.html#name","title":"name()","text":"<p>Get the name of the variable (without backtick prefix).</p> <pre><code>string_t* name();\n</code></pre>"},{"location":"api/cpp.html#data_size_1","title":"data_size()","text":"<p>Get the size of the variable data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#item_t","title":"item_t","text":"<p>Item (constant/functor) class. Defined in <code>&lt;ds/item.hh&gt;</code>.</p> <p>Items represent atomic values or function symbols.</p>"},{"location":"api/cpp.html#methods_2","title":"Methods","text":""},{"location":"api/cpp.html#name_1","title":"name()","text":"<p>Get the name of the item.</p> <pre><code>string_t* name();\n</code></pre>"},{"location":"api/cpp.html#data_size_2","title":"data_size()","text":"<p>Get the size of the item data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_1","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_1","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#list_t","title":"list_t","text":"<p>List class. Defined in <code>&lt;ds/list.hh&gt;</code>.</p> <p>Lists contain ordered sequences of terms.</p>"},{"location":"api/cpp.html#methods_3","title":"Methods","text":""},{"location":"api/cpp.html#length","title":"length()","text":"<p>Get the number of elements in the list.</p> <pre><code>length_t length();\n</code></pre>"},{"location":"api/cpp.html#getitem","title":"getitem()","text":"<p>Get an element by index.</p> <pre><code>term_t* getitem(length_t index);\n</code></pre>"},{"location":"api/cpp.html#data_size_3","title":"data_size()","text":"<p>Get the size of the list data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_2","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_2","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#term_t","title":"term_t","text":"<p>General term class. Defined in <code>&lt;ds/term.hh&gt;</code>.</p> <p>A term can be a variable, item, or list.</p>"},{"location":"api/cpp.html#enum-term_type_t","title":"Enum: term_type_t","text":"<pre><code>enum class term_type_t : min_uint_t {\n    null = 0,\n    variable = 1,\n    item = 2,\n    list = 3\n};\n</code></pre>"},{"location":"api/cpp.html#methods_4","title":"Methods","text":""},{"location":"api/cpp.html#get_type","title":"get_type()","text":"<p>Get the type of this term.</p> <pre><code>term_type_t get_type();\n</code></pre>"},{"location":"api/cpp.html#is_null","title":"is_null()","text":"<p>Check if the term is null.</p> <pre><code>bool is_null();\n</code></pre>"},{"location":"api/cpp.html#variable-item-list","title":"variable() / item() / list()","text":"<p>Get the underlying value as the specific type. Returns nullptr if the term is not of that type.</p> <pre><code>variable_t* variable();\nitem_t* item();\nlist_t* list();\n</code></pre>"},{"location":"api/cpp.html#set_type-set_null-set_variable-set_item-set_list","title":"set_type() / set_null() / set_variable() / set_item() / set_list()","text":"<p>Set the term type.</p> <pre><code>term_t* set_type(term_type_t type, std::byte* check_tail = nullptr);\nterm_t* set_null(std::byte* check_tail = nullptr);\nterm_t* set_variable(std::byte* check_tail = nullptr);\nterm_t* set_item(std::byte* check_tail = nullptr);\nterm_t* set_list(std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#data_size_4","title":"data_size()","text":"<p>Get the size of the term data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_3","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_3","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#ground","title":"ground()","text":"<p>Ground this term using a dictionary to substitute variables.</p> <pre><code>term_t* ground(term_t* term, term_t* dictionary, const char* scope, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#match","title":"match()","text":"<p>Match two terms and produce a unification dictionary.</p> <pre><code>term_t* match(term_t* term_1, term_t* term_2, \n              const char* scope_1, const char* scope_2, \n              std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#rename","title":"rename()","text":"<p>Rename variables by adding prefix and suffix.</p> <pre><code>term_t* rename(term_t* term, term_t* prefix_and_suffix, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#rule_t","title":"rule_t","text":"<p>Logical rule class. Defined in <code>&lt;ds/rule.hh&gt;</code>.</p> <p>A rule consists of premises and a conclusion.</p>"},{"location":"api/cpp.html#methods_5","title":"Methods","text":""},{"location":"api/cpp.html#conclusion","title":"conclusion()","text":"<p>Get the conclusion of the rule.</p> <pre><code>term_t* conclusion();\n</code></pre>"},{"location":"api/cpp.html#only_conclusion","title":"only_conclusion()","text":"<p>Get the conclusion only if there are no premises. Returns nullptr otherwise.</p> <pre><code>term_t* only_conclusion();\n</code></pre>"},{"location":"api/cpp.html#premises","title":"premises()","text":"<p>Get a premise by index.</p> <pre><code>term_t* premises(length_t index);\n</code></pre>"},{"location":"api/cpp.html#premises_count","title":"premises_count()","text":"<p>Get the number of premises.</p> <pre><code>length_t premises_count();\n</code></pre>"},{"location":"api/cpp.html#valid","title":"valid()","text":"<p>Check if the rule is valid.</p> <pre><code>bool valid();\n</code></pre>"},{"location":"api/cpp.html#data_size_5","title":"data_size()","text":"<p>Get the size of the rule data in bytes.</p> <pre><code>length_t data_size();\n</code></pre>"},{"location":"api/cpp.html#head-tail_4","title":"head() / tail()","text":"<p>Get pointers to the data boundaries.</p> <pre><code>std::byte* head();\nstd::byte* tail();\n</code></pre>"},{"location":"api/cpp.html#print-scan_4","title":"print() / scan()","text":"<p>Input/output operations.</p> <pre><code>char* print(char* buffer, char* check_tail = nullptr);\nconst char* scan(const char* buffer, std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#ground_1","title":"ground()","text":"<p>Ground this rule using a dictionary.</p> <pre><code>rule_t* ground(rule_t* rule, term_t* dictionary, const char* scope, \n               std::byte* check_tail = nullptr);\nrule_t* ground(rule_t* rule, rule_t* dictionary, const char* scope, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#match_1","title":"match()","text":"<p>Match this rule with a fact.</p> <pre><code>rule_t* match(rule_t* rule_1, rule_t* rule_2, \n              std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#rename_1","title":"rename()","text":"<p>Rename variables in this rule.</p> <pre><code>rule_t* rename(rule_t* rule, rule_t* prefix_and_suffix, \n               std::byte* check_tail = nullptr);\n</code></pre>"},{"location":"api/cpp.html#search_t","title":"search_t","text":"<p>Search engine class. Defined in <code>&lt;ds/search.hh&gt;</code>.</p> <p>Manages a knowledge base and performs logical inference.</p>"},{"location":"api/cpp.html#constructor","title":"Constructor","text":"<pre><code>search_t(length_t limit_size, length_t buffer_size);\n</code></pre> <p>Parameters:</p> <ul> <li><code>limit_size</code>: Maximum size for each stored rule/fact</li> <li><code>buffer_size</code>: Size of the internal buffer for operations</li> </ul>"},{"location":"api/cpp.html#methods_6","title":"Methods","text":""},{"location":"api/cpp.html#set_limit_size","title":"set_limit_size()","text":"<p>Set the maximum rule/fact size.</p> <pre><code>void set_limit_size(length_t limit_size);\n</code></pre>"},{"location":"api/cpp.html#set_buffer_size","title":"set_buffer_size()","text":"<p>Set the internal buffer size.</p> <pre><code>void set_buffer_size(length_t buffer_size);\n</code></pre>"},{"location":"api/cpp.html#reset","title":"reset()","text":"<p>Clear all rules and facts.</p> <pre><code>void reset();\n</code></pre>"},{"location":"api/cpp.html#add","title":"add()","text":"<p>Add a rule or fact from text.</p> <pre><code>bool add(std::string_view text);\n</code></pre>"},{"location":"api/cpp.html#execute","title":"execute()","text":"<p>Execute one round of inference.</p> <pre><code>length_t execute(const std::function&lt;bool(rule_t*)&gt;&amp; callback);\n</code></pre> <p>Parameters:</p> <ul> <li><code>callback</code>: Function called for each new inference. Return false to continue, true to stop.</li> </ul> <p>Returns: The number of new inferences generated.</p>"},{"location":"api/cpp.html#utility-functions","title":"Utility Functions","text":"<p>Helper functions in <code>&lt;ds/utility.hh&gt;</code>.</p>"},{"location":"api/cpp.html#text_to_term","title":"text_to_term()","text":"<p>Parse text into a term object.</p> <pre><code>std::unique_ptr&lt;term_t&gt; text_to_term(const char* text, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>text</code>: The text representation of the term</li> <li><code>length</code>: Maximum size for the resulting binary term</li> </ul> <p>Returns: A unique_ptr to the created term, or nullptr if length exceeded.</p>"},{"location":"api/cpp.html#term_to_text","title":"term_to_text()","text":"<p>Convert a term object to text.</p> <pre><code>std::unique_ptr&lt;char&gt; term_to_text(term_t* term, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>term</code>: The binary term to convert</li> <li><code>length</code>: Maximum size for the resulting text</li> </ul> <p>Returns: A unique_ptr to the text, or nullptr if length exceeded.</p>"},{"location":"api/cpp.html#text_to_rule","title":"text_to_rule()","text":"<p>Parse text into a rule object.</p> <pre><code>std::unique_ptr&lt;rule_t&gt; text_to_rule(const char* text, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>text</code>: The text representation of the rule</li> <li><code>length</code>: Maximum size for the resulting binary rule</li> </ul> <p>Returns: A unique_ptr to the created rule, or nullptr if length exceeded.</p>"},{"location":"api/cpp.html#rule_to_text","title":"rule_to_text()","text":"<p>Convert a rule object to text.</p> <pre><code>std::unique_ptr&lt;char&gt; rule_to_text(rule_t* rule, length_t length);\n</code></pre> <p>Parameters:</p> <ul> <li><code>rule</code>: The binary rule to convert</li> <li><code>length</code>: Maximum size for the resulting text</li> </ul> <p>Returns: A unique_ptr to the text, or nullptr if length exceeded.</p>"},{"location":"api/python.html","title":"Python API Reference","text":"<p>This page documents the Python API for the <code>apyds</code> package.</p> <pre><code>from apyds import (\n    buffer_size,\n    scoped_buffer_size,\n    String,\n    Variable,\n    Item,\n    List,\n    Term,\n    Rule,\n    Search,\n)\n</code></pre>"},{"location":"api/python.html#buffer_size","title":"buffer_size","text":"<p>Gets the current buffer size, or sets a new buffer size and returns the previous value.</p> <pre><code>def buffer_size(size: int = 0) -&gt; int\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> (optional): The new buffer size to set. If 0 (default), returns current size without modification.</li> </ul> <p>Returns: The previous buffer size value.</p> <p>Example:</p> <pre><code>current_size = buffer_size()       # Get current size\nold_size = buffer_size(2048)       # Set new size, returns old size\n</code></pre>"},{"location":"api/python.html#scoped_buffer_size","title":"scoped_buffer_size","text":"<p>Context manager for temporarily changing the buffer size.</p> <pre><code>@contextmanager\ndef scoped_buffer_size(size: int = 0)\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code>: The temporary buffer size to set.</li> </ul> <p>Example:</p> <pre><code>with scoped_buffer_size(4096):\n    # Operations here use buffer size of 4096\n    pass\n# Buffer size is restored to previous value\n</code></pre>"},{"location":"api/python.html#string","title":"String","text":"<p>Wrapper class for deductive system strings.</p>"},{"location":"api/python.html#constructor","title":"Constructor","text":"<pre><code>def __init__(self, value: String | str | bytes, size: int | None = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string, bytes, or another String)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/python.html#methods","title":"Methods","text":""},{"location":"api/python.html#__str__","title":"__str__()","text":"<p>Convert the value to a string representation.</p> <pre><code>def __str__(self) -&gt; str\n</code></pre>"},{"location":"api/python.html#data","title":"data()","text":"<p>Get the binary representation of the value.</p> <pre><code>def data(self) -&gt; bytes\n</code></pre>"},{"location":"api/python.html#size","title":"size()","text":"<p>Get the size of the data in bytes.</p> <pre><code>def size(self) -&gt; int\n</code></pre> <p>Example:</p> <pre><code>str1 = String(\"hello\")\nstr2 = String(str1.data())  # From binary\nprint(str1)  # \"hello\"\n</code></pre>"},{"location":"api/python.html#variable","title":"Variable","text":"<p>Wrapper class for logical variables in the deductive system.</p>"},{"location":"api/python.html#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, value: Variable | str | bytes, size: int | None = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string starting with backtick, bytes, or another Variable)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/python.html#properties","title":"Properties","text":""},{"location":"api/python.html#name","title":"name","text":"<p>Get the name of this variable (without the backtick prefix).</p> <pre><code>@property\ndef name(self) -&gt; String\n</code></pre> <p>Example:</p> <pre><code>var1 = Variable(\"`X\")\nprint(var1.name)  # \"X\"\nprint(var1)       # \"`X\"\n</code></pre>"},{"location":"api/python.html#item","title":"Item","text":"<p>Wrapper class for items (constants/functors) in the deductive system.</p>"},{"location":"api/python.html#constructor_2","title":"Constructor","text":"<pre><code>def __init__(self, value: Item | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#properties_1","title":"Properties","text":""},{"location":"api/python.html#name_1","title":"name","text":"<p>Get the name of this item.</p> <pre><code>@property\ndef name(self) -&gt; String\n</code></pre> <p>Example:</p> <pre><code>item = Item(\"atom\")\nprint(item.name)  # \"atom\"\n</code></pre>"},{"location":"api/python.html#list","title":"List","text":"<p>Wrapper class for lists in the deductive system.</p>"},{"location":"api/python.html#constructor_3","title":"Constructor","text":"<pre><code>def __init__(self, value: List | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#methods_1","title":"Methods","text":""},{"location":"api/python.html#__len__","title":"__len__()","text":"<p>Get the number of elements in the list.</p> <pre><code>def __len__(self) -&gt; int\n</code></pre>"},{"location":"api/python.html#__getitem__","title":"__getitem__()","text":"<p>Get an element from the list by index.</p> <pre><code>def __getitem__(self, index: int) -&gt; Term\n</code></pre> <p>Example:</p> <pre><code>lst = List(\"(a b c)\")\nprint(len(lst))   # 3\nprint(lst[0])     # \"a\"\n</code></pre>"},{"location":"api/python.html#term","title":"Term","text":"<p>Wrapper class for logical terms in the deductive system. A term can be a variable, item, or list.</p>"},{"location":"api/python.html#constructor_4","title":"Constructor","text":"<pre><code>def __init__(self, value: Term | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#properties_2","title":"Properties","text":""},{"location":"api/python.html#term_1","title":"term","text":"<p>Extracts the underlying term and returns it as its concrete type.</p> <pre><code>@property\ndef term(self) -&gt; Variable | Item | List\n</code></pre>"},{"location":"api/python.html#methods_2","title":"Methods","text":""},{"location":"api/python.html#ground","title":"ground()","text":"<p>Ground this term using a dictionary to substitute variables with values.</p> <pre><code>def ground(self, other: Term, scope: str | None = None) -&gt; Term | None\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: A term representing a dictionary (list of pairs)</li> <li><code>scope</code> (optional): Scope string for variable scoping</li> </ul> <p>Returns: The grounded term, or None if grounding fails.</p> <p>Example:</p> <pre><code>a = Term(\"`a\")\ndict = Term(\"((`a b))\")\nresult = a.ground(dict)\nif result is not None:\n    print(result)  # \"b\"\n</code></pre>"},{"location":"api/python.html#rename","title":"rename()","text":"<p>Rename all variables in this term by adding prefix and suffix.</p> <pre><code>def rename(self, prefix_and_suffix: Term) -&gt; Term | None\n</code></pre> <p>Parameters:</p> <ul> <li><code>prefix_and_suffix</code>: A term with format <code>((prefix) (suffix))</code></li> </ul> <p>Returns: The renamed term, or None if renaming fails.</p> <p>Example:</p> <pre><code>term = Term(\"`x\")\nspec = Term(\"((pre_) (_suf))\")\nresult = term.rename(spec)\nif result is not None:\n    print(result)  # \"`pre_x_suf\"\n</code></pre>"},{"location":"api/python.html#rule","title":"Rule","text":"<p>Wrapper class for logical rules in the deductive system.</p>"},{"location":"api/python.html#constructor_5","title":"Constructor","text":"<pre><code>def __init__(self, value: Rule | str | bytes, size: int | None = None)\n</code></pre>"},{"location":"api/python.html#properties_3","title":"Properties","text":""},{"location":"api/python.html#conclusion","title":"conclusion","text":"<p>Get the conclusion of the rule.</p> <pre><code>@property\ndef conclusion(self) -&gt; Term\n</code></pre>"},{"location":"api/python.html#methods_3","title":"Methods","text":""},{"location":"api/python.html#__len___1","title":"__len__()","text":"<p>Get the number of premises in the rule.</p> <pre><code>def __len__(self) -&gt; int\n</code></pre>"},{"location":"api/python.html#__getitem___1","title":"__getitem__()","text":"<p>Get a premise term by index.</p> <pre><code>def __getitem__(self, index: int) -&gt; Term\n</code></pre>"},{"location":"api/python.html#ground_1","title":"ground()","text":"<p>Ground this rule using a dictionary.</p> <pre><code>def ground(self, other: Rule, scope: str | None = None) -&gt; Rule | None\n</code></pre>"},{"location":"api/python.html#__matmul__-match","title":"__matmul__() / match","text":"<p>Match this rule with another rule using unification.</p> <pre><code>def __matmul__(self, other: Rule) -&gt; Rule | None\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: The rule to match against (must be a fact without premises)</li> </ul> <p>Returns: The matched rule, or None if matching fails.</p> <p>Example:</p> <pre><code>mp = Rule(\"(`p -&gt; `q)\\n`p\\n`q\\n\")\npq = Rule(\"((! (! `x)) -&gt; `x)\")\nresult = mp @ pq\nif result is not None:\n    print(result)\n    # \"(! (! `x))\\n----------\\n`x\\n\"\n</code></pre>"},{"location":"api/python.html#rename_1","title":"rename()","text":"<p>Rename all variables in this rule.</p> <pre><code>def rename(self, prefix_and_suffix: Rule) -&gt; Rule | None\n</code></pre>"},{"location":"api/python.html#search","title":"Search","text":"<p>Search engine for the deductive system.</p>"},{"location":"api/python.html#constructor_6","title":"Constructor","text":"<pre><code>def __init__(self, limit_size: int = 1000, buffer_size: int = 10000)\n</code></pre> <p>Parameters:</p> <ul> <li><code>limit_size</code> (optional): Size of the buffer for storing rules/facts (default: 1000)</li> <li><code>buffer_size</code> (optional): Size of the buffer for internal operations (default: 10000)</li> </ul>"},{"location":"api/python.html#methods_4","title":"Methods","text":""},{"location":"api/python.html#set_limit_size","title":"set_limit_size()","text":"<p>Set the size of the buffer for storing final objects.</p> <pre><code>def set_limit_size(self, limit_size: int) -&gt; None\n</code></pre>"},{"location":"api/python.html#set_buffer_size","title":"set_buffer_size()","text":"<p>Set the buffer size for internal operations.</p> <pre><code>def set_buffer_size(self, buffer_size: int) -&gt; None\n</code></pre>"},{"location":"api/python.html#reset","title":"reset()","text":"<p>Reset the search engine, clearing all rules and facts.</p> <pre><code>def reset(self) -&gt; None\n</code></pre>"},{"location":"api/python.html#add","title":"add()","text":"<p>Add a rule or fact to the knowledge base.</p> <pre><code>def add(self, text: str) -&gt; bool\n</code></pre> <p>Returns: True if successfully added, False otherwise.</p>"},{"location":"api/python.html#execute","title":"execute()","text":"<p>Execute the search engine with a callback for each inferred rule.</p> <pre><code>def execute(self, callback: Callable[[Rule], bool]) -&gt; int\n</code></pre> <p>Parameters:</p> <ul> <li><code>callback</code>: Function called for each candidate rule. Return False to continue, True to stop.</li> </ul> <p>Returns: The number of rules processed.</p> <p>Example:</p> <pre><code>search = Search(1000, 10000)\nsearch.add(\"(`P -&gt; `Q) `P `Q\")\nsearch.add(\"(! (! X))\")\n\ndef callback(candidate):\n    print(candidate)\n    return False  # Continue searching\n\nsearch.execute(callback)\n</code></pre>"},{"location":"api/typescript.html","title":"TypeScript API Reference","text":"<p>This page documents the TypeScript API for the <code>atsds</code> package. The documentation is generated from the TypeScript source code.</p> <pre><code>import { \n    buffer_size,\n    string_t, \n    variable_t, \n    item_t, \n    list_t, \n    term_t, \n    rule_t, \n    search_t \n} from \"atsds\";\n</code></pre>"},{"location":"api/typescript.html#buffer_size","title":"buffer_size","text":"<p>Gets the current buffer size, or sets a new buffer size and returns the previous value.</p> <pre><code>function buffer_size(size?: number): number;\n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> (optional): The new buffer size to set. If 0 or omitted, returns current size without modification.</li> </ul> <p>Returns: The previous buffer size value.</p> <p>Example:</p> <pre><code>const currentSize = buffer_size();     // Get current size\nconst oldSize = buffer_size(2048);     // Set new size, returns old size\n</code></pre>"},{"location":"api/typescript.html#string_t","title":"string_t","text":"<p>Wrapper class for deductive system strings.</p>"},{"location":"api/typescript.html#constructor","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | string_t, size?: number)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string, buffer, or another string_t)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/typescript.html#methods","title":"Methods","text":""},{"location":"api/typescript.html#tostring","title":"toString()","text":"<p>Convert the value to a string representation.</p> <pre><code>toString(): string\n</code></pre>"},{"location":"api/typescript.html#data","title":"data()","text":"<p>Get the binary representation of the value.</p> <pre><code>data(): Buffer\n</code></pre>"},{"location":"api/typescript.html#size","title":"size()","text":"<p>Get the size of the data in bytes.</p> <pre><code>size(): number\n</code></pre>"},{"location":"api/typescript.html#copy","title":"copy()","text":"<p>Create a deep copy of this instance.</p> <pre><code>copy(): string_t\n</code></pre>"},{"location":"api/typescript.html#key","title":"key()","text":"<p>Get a key representation for equality comparison.</p> <pre><code>key(): string\n</code></pre> <p>Example:</p> <pre><code>const str1 = new string_t(\"hello\");\nconst str2 = new string_t(str1.data());\nconsole.log(str1.toString());  // \"hello\"\n</code></pre>"},{"location":"api/typescript.html#variable_t","title":"variable_t","text":"<p>Wrapper class for logical variables in the deductive system.</p>"},{"location":"api/typescript.html#constructor_1","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | variable_t, size?: number)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Initial value (string starting with backtick, buffer, or another variable_t)</li> <li><code>size</code> (optional): Buffer capacity for internal storage</li> </ul>"},{"location":"api/typescript.html#methods_1","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#name","title":"name()","text":"<p>Get the name of this variable (without the backtick prefix).</p> <pre><code>name(): string_t\n</code></pre> <p>Example:</p> <pre><code>const var1 = new variable_t(\"`X\");\nconsole.log(var1.name().toString());  // \"X\"\nconsole.log(var1.toString());         // \"`X\"\n</code></pre>"},{"location":"api/typescript.html#item_t","title":"item_t","text":"<p>Wrapper class for items (constants/functors) in the deductive system.</p>"},{"location":"api/typescript.html#constructor_2","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | item_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_2","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#name_1","title":"name()","text":"<p>Get the name of this item.</p> <pre><code>name(): string_t\n</code></pre> <p>Example:</p> <pre><code>const item = new item_t(\"atom\");\nconsole.log(item.name().toString());  // \"atom\"\n</code></pre>"},{"location":"api/typescript.html#list_t","title":"list_t","text":"<p>Wrapper class for lists in the deductive system.</p>"},{"location":"api/typescript.html#constructor_3","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | list_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_3","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#length","title":"length()","text":"<p>Get the number of elements in the list.</p> <pre><code>length(): number\n</code></pre>"},{"location":"api/typescript.html#getitem","title":"getitem()","text":"<p>Get an element from the list by index.</p> <pre><code>getitem(index: number): term_t\n</code></pre> <p>Example:</p> <pre><code>const list = new list_t(\"(a b c)\");\nconsole.log(list.length());           // 3\nconsole.log(list.getitem(0).toString());  // \"a\"\n</code></pre>"},{"location":"api/typescript.html#term_t","title":"term_t","text":"<p>Wrapper class for logical terms in the deductive system. A term can be a variable, item, or list.</p>"},{"location":"api/typescript.html#constructor_4","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | term_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_4","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#term","title":"term()","text":"<p>Extracts the underlying term and returns it as its concrete type.</p> <pre><code>term(): variable_t | item_t | list_t\n</code></pre>"},{"location":"api/typescript.html#ground","title":"ground()","text":"<p>Ground this term using a dictionary to substitute variables with values.</p> <pre><code>ground(other: term_t, scope?: string): term_t | null\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: A term representing a dictionary (list of pairs)</li> <li><code>scope</code> (optional): Scope string for variable scoping</li> </ul> <p>Returns: The grounded term, or null if grounding fails.</p> <p>Example:</p> <pre><code>const a = new term_t(\"`a\");\nconst dict = new term_t(\"((`a b))\");\nconst result = a.ground(dict);\nif (result !== null) {\n    console.log(result.toString());  // \"b\"\n}\n</code></pre>"},{"location":"api/typescript.html#rename","title":"rename()","text":"<p>Rename all variables in this term by adding prefix and suffix.</p> <pre><code>rename(prefix_and_suffix: term_t): term_t | null\n</code></pre> <p>Parameters:</p> <ul> <li><code>prefix_and_suffix</code>: A term with format <code>((prefix) (suffix))</code></li> </ul> <p>Returns: The renamed term, or null if renaming fails.</p> <p>Example:</p> <pre><code>const term = new term_t(\"`x\");\nconst spec = new term_t(\"((pre_) (_suf))\");\nconst result = term.rename(spec);\nif (result !== null) {\n    console.log(result.toString());  // \"`pre_x_suf\"\n}\n</code></pre>"},{"location":"api/typescript.html#rule_t","title":"rule_t","text":"<p>Wrapper class for logical rules in the deductive system.</p>"},{"location":"api/typescript.html#constructor_5","title":"Constructor","text":"<pre><code>constructor(value: string | Buffer | rule_t, size?: number)\n</code></pre>"},{"location":"api/typescript.html#methods_5","title":"Methods","text":"<p>Inherits all methods from <code>string_t</code>, plus:</p>"},{"location":"api/typescript.html#length_1","title":"length()","text":"<p>Get the number of premises in the rule.</p> <pre><code>length(): number\n</code></pre>"},{"location":"api/typescript.html#getitem_1","title":"getitem()","text":"<p>Get a premise term by index.</p> <pre><code>getitem(index: number): term_t\n</code></pre>"},{"location":"api/typescript.html#conclusion","title":"conclusion()","text":"<p>Get the conclusion of the rule.</p> <pre><code>conclusion(): term_t\n</code></pre>"},{"location":"api/typescript.html#ground_1","title":"ground()","text":"<p>Ground this rule using a dictionary.</p> <pre><code>ground(other: rule_t, scope?: string): rule_t | null\n</code></pre>"},{"location":"api/typescript.html#match","title":"match()","text":"<p>Match this rule with another rule using unification.</p> <pre><code>match(other: rule_t): rule_t | null\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code>: The rule to match against (must be a fact without premises)</li> </ul> <p>Returns: The matched rule, or null if matching fails.</p> <p>Example:</p> <pre><code>const mp = new rule_t(\"(`p -&gt; `q)\\n`p\\n`q\\n\");\nconst pq = new rule_t(\"((! (! `x)) -&gt; `x)\");\nconst result = mp.match(pq);\nif (result !== null) {\n    console.log(result.toString());\n    // \"(! (! `x))\\n----------\\n`x\\n\"\n}\n</code></pre>"},{"location":"api/typescript.html#rename_1","title":"rename()","text":"<p>Rename all variables in this rule.</p> <pre><code>rename(prefix_and_suffix: rule_t): rule_t | null\n</code></pre>"},{"location":"api/typescript.html#search_t","title":"search_t","text":"<p>Search engine for the deductive system.</p>"},{"location":"api/typescript.html#constructor_6","title":"Constructor","text":"<pre><code>constructor(limit_size?: number, buffer_size?: number)\n</code></pre> <p>Parameters:</p> <ul> <li><code>limit_size</code> (optional): Size of the buffer for storing rules/facts (default: 1000)</li> <li><code>buffer_size</code> (optional): Size of the buffer for internal operations (default: 10000)</li> </ul>"},{"location":"api/typescript.html#methods_6","title":"Methods","text":""},{"location":"api/typescript.html#set_limit_size","title":"set_limit_size()","text":"<p>Set the size of the buffer for storing final objects.</p> <pre><code>set_limit_size(limit_size: number): void\n</code></pre>"},{"location":"api/typescript.html#set_buffer_size","title":"set_buffer_size()","text":"<p>Set the buffer size for internal operations.</p> <pre><code>set_buffer_size(buffer_size: number): void\n</code></pre>"},{"location":"api/typescript.html#reset","title":"reset()","text":"<p>Reset the search engine, clearing all rules and facts.</p> <pre><code>reset(): void\n</code></pre>"},{"location":"api/typescript.html#add","title":"add()","text":"<p>Add a rule or fact to the knowledge base.</p> <pre><code>add(text: string): boolean\n</code></pre> <p>Returns: True if successfully added, false otherwise.</p>"},{"location":"api/typescript.html#execute","title":"execute()","text":"<p>Execute the search engine with a callback for each inferred rule.</p> <pre><code>execute(callback: (candidate: rule_t) =&gt; boolean): number\n</code></pre> <p>Parameters:</p> <ul> <li><code>callback</code>: Function called for each candidate rule. Return false to continue, true to stop.</li> </ul> <p>Returns: The number of rules processed.</p> <p>Example:</p> <pre><code>const search = new search_t(1000, 10000);\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\nsearch.add(\"(! (! X))\");\n\nsearch.execute((candidate) =&gt; {\n    console.log(candidate.toString());\n    return false;  // Continue searching\n});\n</code></pre>"},{"location":"concepts/rules.html","title":"Rules","text":"<p>Rules are the core mechanism for representing logical inference in DS. This page explains how rules work and how to use them.</p>"},{"location":"concepts/rules.html#rule-structure","title":"Rule Structure","text":"<p>A rule consists of:</p> <ul> <li>Premises: Zero or more conditions (above the line)</li> <li>Conclusion: The result when all premises are satisfied (below the line)</li> </ul>"},{"location":"concepts/rules.html#text-representation","title":"Text Representation","text":"<p>Rules are written with premises and conclusion separated by dashes:</p> <pre><code>premise1\npremise2\n----------\nconclusion\n</code></pre> <p>A fact is a rule with no premises:</p> <pre><code>(parent john mary)\n</code></pre> <p>Or explicitly:</p> <pre><code>----------\n(parent john mary)\n</code></pre>"},{"location":"concepts/rules.html#examples","title":"Examples","text":"<p>Modus Ponens (if P implies Q and P is true, then Q is true):</p> <pre><code>(`P -&gt; `Q)\n`P\n----------\n`Q\n</code></pre> <p>Family Relationship (if X is the father of Y, then X is a parent of Y):</p> <pre><code>(father `X `Y)\n----------\n(parent `X `Y)\n</code></pre>"},{"location":"concepts/rules.html#creating-rules","title":"Creating Rules","text":"TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Create a fact\nconst fact = new rule_t(\"(parent john mary)\");\n\n// Create a rule with premises\nconst rule = new rule_t(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\n\n// Access rule components\nconsole.log(`Number of premises: ${rule.length()}`);  // 1\nconsole.log(`First premise: ${rule.getitem(0).toString()}`);  // (father `X `Y)\nconsole.log(`Conclusion: ${rule.conclusion().toString()}`);  // (parent `X `Y)\n</code></pre> <pre><code>import apyds\n\n# Create a fact\nfact = apyds.Rule(\"(parent john mary)\")\n\n# Create a rule with premises\n# Using explicit separator\nrule = apyds.Rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\n\n# Access rule components\nprint(f\"Number of premises: {len(rule)}\")  # 1\nprint(f\"First premise: {rule[0]}\")  # (father `X `Y)\nprint(f\"Conclusion: {rule.conclusion}\")  # (parent `X `Y)\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a fact\n    auto fact = ds::text_to_rule(\"(parent john mary)\", 1000);\n\n    // Create a rule with premises\n    auto rule = ds::text_to_rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\", 1000);\n\n    // Access rule components\n    std::cout &lt;&lt; \"Number of premises: \" &lt;&lt; rule-&gt;premises_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Conclusion: \" &lt;&lt; ds::term_to_text(rule-&gt;conclusion(), 1000).get() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#rule-operations","title":"Rule Operations","text":""},{"location":"concepts/rules.html#grounding","title":"Grounding","text":"<p>Grounding substitutes variables in a rule with values from a dictionary.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Create a rule with variables\nconst rule = new rule_t(\"`a\");\n\n// Create a dictionary\nconst dictionary = new rule_t(\"((`a b))\");\n\n// Ground the rule\nconst result = rule.ground(dictionary);\nif (result !== null) {\n    console.log(result.toString());  // ----\\nb\\n\n}\n</code></pre> <pre><code>import apyds\n\n# Create a rule with variables\nrule = apyds.Rule(\"`a\")\n\n# Create a dictionary\ndictionary = apyds.Rule(\"((`a b))\")\n\n# Ground the rule\nresult = rule.ground(dictionary)\nprint(result)  # ----\\nb\\n\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a rule with variables\n    auto rule = ds::text_to_rule(\"`a\", 1000);\n\n    // Create a dictionary\n    auto dictionary = ds::text_to_rule(\"((`a b))\", 1000);\n\n    // Ground the rule\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::rule_t*&gt;(buffer);\n    result-&gt;ground(rule.get(), dictionary.get(), nullptr, buffer + 1000);\n\n    std::cout &lt;&lt; ds::rule_to_text(result, 1000).get() &lt;&lt; std::endl;  // ----\\nb\\n\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#matching","title":"Matching","text":"<p>Matching unifies the first premise of a rule with a fact, producing a new rule with one fewer premise.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Modus ponens rule\nconst mp = new rule_t(\"(`p -&gt; `q)\\n`p\\n`q\\n\");\n\n// Double negation elimination axiom\nconst axiom = new rule_t(\"((! (! `x)) -&gt; `x)\");\n\n// Match\nconst result = mp.match(axiom);\nif (result !== null) {\n    console.log(result.toString());\n    // (! (! `x))\n    // ----------\n    // `x\n}\n</code></pre> <pre><code>import apyds\n\n# Modus ponens rule: if (P -&gt; Q) and P then Q\nmp = apyds.Rule(\"(`p -&gt; `q)\\n`p\\n`q\\n\")\n\n# A fact: double negation elimination axiom\naxiom = apyds.Rule(\"((! (! `x)) -&gt; `x)\")\n\n# Match: apply axiom to modus ponens\nresult = mp @ axiom  # Uses @ operator\nprint(result)\n# Output:\n# (! (! `x))\n# ----------\n# `x\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Modus ponens rule\n    auto mp = ds::text_to_rule(\"(`p -&gt; `q)\\n`p\\n`q\\n\", 1000);\n\n    // Double negation elimination axiom\n    auto axiom = ds::text_to_rule(\"((! (! `x)) -&gt; `x)\", 1000);\n\n    // Match\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::rule_t*&gt;(buffer);\n    result-&gt;match(mp.get(), axiom.get(), buffer + 1000);\n\n    std::cout &lt;&lt; ds::rule_to_text(result, 1000).get() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#renaming","title":"Renaming","text":"<p>Renaming adds prefixes and/or suffixes to all variables in a rule.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\n// Create a rule\nconst rule = new rule_t(\"`x\");\n\n// Rename with prefix and suffix\nconst spec = new rule_t(\"((pre_) (_suf))\");\nconst result = rule.rename(spec);\nif (result !== null) {\n    console.log(result.toString());  // ----\\n`pre_x_suf\\n\n}\n</code></pre> <pre><code>import apyds\n\n# Create a rule\nrule = apyds.Rule(\"`x\")\n\n# Rename with prefix and suffix\nspec = apyds.Rule(\"((pre_) (_suf))\")\nresult = rule.rename(spec)\nprint(result)  # ----\\n`pre_x_suf\\n\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a rule\n    auto rule = ds::text_to_rule(\"`x\", 1000);\n\n    // Rename with prefix and suffix\n    auto spec = ds::text_to_rule(\"((pre_) (_suf))\", 1000);\n\n    // Rename the rule\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::rule_t*&gt;(buffer);\n    result-&gt;rename(rule.get(), spec.get(), buffer + 1000);\n\n    std::cout &lt;&lt; ds::rule_to_text(result, 1000).get() &lt;&lt; std::endl;  // ----\\n`pre_x_suf\\n\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#rule-comparison","title":"Rule Comparison","text":"<p>Rules can be compared for equality. Two rules are equal if they have the same binary representation.</p> TypeScriptPythonC++ <pre><code>import { rule_t } from \"atsds\";\n\nconst rule1 = new rule_t(\"(a b c)\");\nconst rule2 = new rule_t(\"(a b c)\");\nconst rule3 = new rule_t(\"(a b d)\");\n\nconsole.log(rule1.key() === rule2.key());  // true\nconsole.log(rule1.key() === rule3.key());  // false\n</code></pre> <pre><code>import apyds\n\nrule1 = apyds.Rule(\"(a b c)\")\nrule2 = apyds.Rule(\"(a b c)\")\nrule3 = apyds.Rule(\"(a b d)\")\n\nprint(rule1 == rule2)  # True\nprint(rule1 == rule3)  # False\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto rule1 = ds::text_to_rule(\"(a b c)\", 1000);\n    auto rule2 = ds::text_to_rule(\"(a b c)\", 1000);\n    auto rule3 = ds::text_to_rule(\"(a b d)\", 1000);\n\n    bool eq12 = rule1-&gt;data_size() == rule2-&gt;data_size() &amp;&amp;\n                memcmp(rule1-&gt;head(), rule2-&gt;head(), rule1-&gt;data_size()) == 0;\n    bool eq13 = rule1-&gt;data_size() == rule3-&gt;data_size() &amp;&amp;\n                memcmp(rule1-&gt;head(), rule3-&gt;head(), rule1-&gt;data_size()) == 0;\n\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; eq12 &lt;&lt; std::endl;  // true\n    std::cout &lt;&lt; eq13 &lt;&lt; std::endl;  // false\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/rules.html#see-also","title":"See Also","text":"<ul> <li>Terms - Building blocks for rules</li> <li>Search Engine - Performing inference with rules</li> </ul>"},{"location":"concepts/search.html","title":"Search Engine","text":"<p>The search engine is the core inference mechanism in DS. It manages a knowledge base of rules and facts, and performs logical inference by matching rules with facts.</p>"},{"location":"concepts/search.html#overview","title":"Overview","text":"<p>The search engine:</p> <ol> <li>Maintains a collection of rules and facts</li> <li>Iteratively applies rules to generate new facts</li> <li>Notifies you of each new inference via a callback</li> </ol>"},{"location":"concepts/search.html#creating-a-search-engine","title":"Creating a Search Engine","text":"PythonTypeScriptC++ <pre><code>import apyds\n\n# Create with default sizes\nsearch = apyds.Search()\n\n# Create with custom sizes\nsearch = apyds.Search(limit_size=2000, buffer_size=20000)\n</code></pre> <pre><code>import { search_t } from \"atsds\";\n\n// Create with default sizes\nconst search = new search_t();\n\n// Create with custom sizes\nconst search2 = new search_t(2000, 20000);\n</code></pre> <pre><code>#include &lt;ds/search.hh&gt;\n\n// Create search engine\nds::search_t search(1000, 10000);\n</code></pre>"},{"location":"concepts/search.html#parameters","title":"Parameters","text":"<ul> <li>limit_size: Maximum size (in bytes) for each stored rule/fact (default: 1000)</li> <li>buffer_size: Size of the internal buffer for intermediate operations (default: 10000)</li> </ul>"},{"location":"concepts/search.html#adding-rules-and-facts","title":"Adding Rules and Facts","text":"<p>Use the <code>add()</code> method to add rules and facts to the knowledge base.</p> PythonTypeScriptC++ <pre><code>import apyds\n\nsearch = apyds.Search()\n\n# Add a fact\nsearch.add(\"(parent john mary)\")\n\n# Add a rule with premises\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\n\n# Add multiple facts and rules\nsearch.add(\"(father john mary)\")\nsearch.add(\"(father john bob)\")\nsearch.add(\"(mother mary alice)\")\n</code></pre> <pre><code>import { search_t } from \"atsds\";\n\nconst search = new search_t();\n\n// Add a fact\nsearch.add(\"(parent john mary)\");\n\n// Add a rule with premises\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\n</code></pre> <pre><code>ds::search_t search(1000, 10000);\n\n// Add a fact\nsearch.add(\"(parent john mary)\");\n\n// Add a rule\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\n</code></pre>"},{"location":"concepts/search.html#executing-search","title":"Executing Search","text":"<p>The <code>execute()</code> method performs one round of inference. It matches all rules against all facts and generates new conclusions.</p> PythonTypeScriptC++ <pre><code>import apyds\n\nsearch = apyds.Search()\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\nsearch.add(\"(father john mary)\")\n\ndef callback(rule):\n    print(f\"Found: {rule}\")\n    return False  # Continue searching\n\n# Execute one round\ncount = search.execute(callback)\nprint(f\"Generated {count} new facts\")\n</code></pre> <pre><code>import { search_t } from \"atsds\";\n\nconst search = new search_t();\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\nsearch.add(\"(father john mary)\");\n\nconst count = search.execute((rule) =&gt; {\n    console.log(`Found: ${rule.toString()}`);\n    return false;  // Continue searching\n});\n\nconsole.log(`Generated ${count} new facts`);\n</code></pre> <pre><code>ds::search_t search(1000, 10000);\nsearch.add(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\nsearch.add(\"(father john mary)\");\n\nauto count = search.execute([](ds::rule_t* rule) {\n    printf(\"Found: %s\\n\", ds::rule_to_text(rule, 1000).get());\n    return false;  // Continue searching\n});\n\nprintf(\"Generated %lu new facts\\n\", count);\n</code></pre>"},{"location":"concepts/search.html#callback-function","title":"Callback Function","text":"<p>The callback receives each newly inferred rule and should return:</p> <ul> <li><code>False</code> (Python) / <code>false</code> (TypeScript/C++): Continue searching</li> <li><code>True</code> (Python) / <code>true</code> (TypeScript/C++): Stop searching</li> </ul>"},{"location":"concepts/search.html#searching-for-a-target","title":"Searching for a Target","text":"<p>To search until a specific target is found:</p> PythonTypeScript <pre><code>import apyds\n\nsearch = apyds.Search(1000, 10000)\n\n# Set up propositional logic\nsearch.add(\"(`P -&gt; `Q) `P `Q\")  # Modus ponens\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\")  # Axiom 1\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\")  # Axiom 2\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\")  # Axiom 3\nsearch.add(\"(! (! X))\")  # Premise\n\ntarget = apyds.Rule(\"X\")\n\nwhile True:\n    found = False\n    def check(candidate):\n        nonlocal found\n        if candidate == target:\n            print(f\"Found: {candidate}\")\n            found = True\n            return True\n        return False\n    search.execute(check)\n    if found:\n        break\n</code></pre> <pre><code>import { rule_t, search_t } from \"atsds\";\n\nconst search = new search_t(1000, 10000);\n\n// Set up propositional logic\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\");\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\nsearch.add(\"(! (! X))\");\n\nconst target = new rule_t(\"X\");\n\nwhile (true) {\n    let found = false;\n    search.execute((candidate) =&gt; {\n        if (candidate.key() === target.key()) {\n            console.log(\"Found:\", candidate.toString());\n            found = true;\n            return true;\n        }\n        return false;\n    });\n    if (found) break;\n}\n</code></pre>"},{"location":"concepts/search.html#configuration-methods","title":"Configuration Methods","text":""},{"location":"concepts/search.html#set-limit-size","title":"Set Limit Size","text":"<p>Controls the maximum size for each stored rule/fact:</p> PythonTypeScriptC++ <pre><code>search.set_limit_size(2000)\n</code></pre> <pre><code>search.set_limit_size(2000);\n</code></pre> <pre><code>search.set_limit_size(2000);\n</code></pre>"},{"location":"concepts/search.html#set-buffer-size","title":"Set Buffer Size","text":"<p>Controls the internal buffer size for operations:</p> PythonTypeScriptC++ <pre><code>search.set_buffer_size(20000)\n</code></pre> <pre><code>search.set_buffer_size(20000);\n</code></pre> <pre><code>search.set_buffer_size(20000);\n</code></pre>"},{"location":"concepts/search.html#reset","title":"Reset","text":"<p>Clears all rules and facts:</p> PythonTypeScriptC++ <pre><code>search.reset()\n</code></pre> <pre><code>search.reset();\n</code></pre> <pre><code>search.reset();\n</code></pre>"},{"location":"concepts/search.html#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Buffer Size: Larger buffers allow more complex intermediate results but use more memory</li> <li>Limit Size: Restricts maximum rule/fact complexity - too small may reject valid rules</li> <li>Iterative Execution: Call <code>execute()</code> in a loop to continue inference until convergence</li> <li>Early Termination: Return <code>true</code> from callback to stop as soon as target is found</li> </ol>"},{"location":"concepts/search.html#see-also","title":"See Also","text":"<ul> <li>Terms - Building blocks for the search</li> <li>Rules - How rules are structured and matched</li> </ul>"},{"location":"concepts/terms.html","title":"Terms","text":"<p>Terms are the fundamental building blocks of the deductive system. This page explains the different types of terms and how to work with them.</p>"},{"location":"concepts/terms.html#term-types","title":"Term Types","text":"<p>The deductive system supports three basic types of terms:</p>"},{"location":"concepts/terms.html#variables","title":"Variables","text":"<p>Variables are placeholders that can be unified with other terms during inference. They are prefixed with a backtick (<code>`</code>).</p> <pre><code>`X\n`variable_name\n`P\n`Q\n</code></pre> <p>Variables are used in rules to represent any term that can match during unification.</p>"},{"location":"concepts/terms.html#items","title":"Items","text":"<p>Items represent constants or functors. They are atomic values without any special prefix.</p> <pre><code>hello\natom\nfather\n!\n-&gt;\n</code></pre> <p>Items can represent:</p> <ul> <li>Constants: Atomic values like <code>john</code>, <code>mary</code>, <code>42</code></li> <li>Functors: Symbols that combine other terms, like <code>father</code>, <code>-&gt;</code>, <code>!</code></li> </ul>"},{"location":"concepts/terms.html#lists","title":"Lists","text":"<p>Lists are ordered sequences of terms enclosed in parentheses. They can contain any combination of variables, items, and nested lists.</p> <pre><code>(a b c)\n(father john mary)\n(-&gt; P Q)\n(! (! X))\n</code></pre> <p>Lists are the primary way to build complex structures in the deductive system.</p>"},{"location":"concepts/terms.html#creating-terms","title":"Creating Terms","text":"TypeScriptPythonC++ <pre><code>import { variable_t, item_t, list_t, term_t } from \"atsds\";\n\n// Create a variable\nconst var1 = new variable_t(\"`X\");\nconsole.log(`Variable name: ${var1.name().toString()}`);  // X\n\n// Create an item\nconst item = new item_t(\"hello\");\nconsole.log(`Item name: ${item.name().toString()}`);  // hello\n\n// Create a list\nconst lst = new list_t(\"(a b c)\");\nconsole.log(`List length: ${lst.length()}`);  // 3\nconsole.log(`First element: ${lst.getitem(0).toString()}`);  // a\n\n// Create a generic term\nconst term = new term_t(\"(f `x)\");\n// Access the underlying type\nconst inner = term.term();  // Returns a list_t\n</code></pre> <pre><code>import apyds\n\n# Create a variable\nvar = apyds.Variable(\"`X\")\nprint(f\"Variable name: {var.name}\")  # X\n\n# Create an item\nitem = apyds.Item(\"hello\")\nprint(f\"Item name: {item.name}\")  # hello\n\n# Create a list\nlst = apyds.List(\"(a b c)\")\nprint(f\"List length: {len(lst)}\")  # 3\nprint(f\"First element: {lst[0]}\")  # a\n\n# Create a generic term\nterm = apyds.Term(\"(f `x)\")\n# Access the underlying type\ninner = term.term  # Returns a List\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a variable\n    auto var = ds::text_to_variable(\"`X\", 1000);\n\n    // Create an item\n    auto item = ds::text_to_item(\"hello\", 1000);\n\n    // Create a list\n    auto lst = ds::text_to_list(\"(a b c)\", 1000);\n    std::cout &lt;&lt; \"List length: \" &lt;&lt; lst-&gt;length() &lt;&lt; std::endl;\n\n    // Create a generic term\n    auto term = ds::text_to_term(\"(f `x)\", 1000);\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/terms.html#term-operations","title":"Term Operations","text":""},{"location":"concepts/terms.html#grounding","title":"Grounding","text":"<p>Grounding substitutes variables in a term with values from a dictionary. The dictionary is a list of key-value pairs where each key is a variable and each value is its substitution.</p> TypeScriptPythonC++ <pre><code>import { term_t } from \"atsds\";\n\n// Create a term with a variable\nconst term = new term_t(\"`a\");\n\n// Create a dictionary for substitution\nconst dictionary = new term_t(\"((`a b))\");\n\n// Ground the term\nconst result = term.ground(dictionary);\nif (result !== null) {\n    console.log(result.toString());  // b\n}\n</code></pre> <pre><code>import apyds\n\n# Create a term with a variable\nterm = apyds.Term(\"`a\")\n\n# Create a dictionary for substitution\n# Format: ((variable value) ...)\ndictionary = apyds.Term(\"((`a b))\")\n\n# Ground the term\nresult = term.ground(dictionary)\nprint(result)  # b\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a term with a variable\n    auto term = ds::text_to_term(\"`a\", 1000);\n\n    // Create a dictionary for substitution\n    auto dictionary = ds::text_to_term(\"((`a b))\", 1000);\n\n    // Ground the term\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::term_t*&gt;(buffer);\n    result-&gt;ground(term.get(), dictionary.get(), nullptr, buffer + 1000);\n\n    std::cout &lt;&lt; ds::term_to_text(result, 1000).get() &lt;&lt; std::endl;  // b\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/terms.html#renaming","title":"Renaming","text":"<p>Renaming adds prefixes and/or suffixes to all variables in a term. This is useful for avoiding variable name collisions during unification.</p> TypeScriptPythonC++ <pre><code>import { term_t } from \"atsds\";\n\n// Create a term with a variable\nconst term = new term_t(\"`x\");\n\n// Create prefix and suffix specification\nconst spec = new term_t(\"((pre_) (_suf))\");\n\n// Rename the term\nconst result = term.rename(spec);\nif (result !== null) {\n    console.log(result.toString());  // `pre_x_suf\n}\n</code></pre> <pre><code>import apyds\n\n# Create a term with a variable\nterm = apyds.Term(\"`x\")\n\n# Create prefix and suffix specification\n# Format: ((prefix) (suffix))\nspec = apyds.Term(\"((pre_) (_suf))\")\n\n# Rename the term\nresult = term.rename(spec)\nprint(result)  # `pre_x_suf\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a term with a variable\n    auto term = ds::text_to_term(\"`x\", 1000);\n\n    // Create prefix and suffix specification\n    auto spec = ds::text_to_term(\"((pre_) (_suf))\", 1000);\n\n    // Rename the term\n    std::byte buffer[1000];\n    auto result = reinterpret_cast&lt;ds::term_t*&gt;(buffer);\n    result-&gt;rename(term.get(), spec.get(), buffer + 1000);\n\n    std::cout &lt;&lt; ds::term_to_text(result, 1000).get() &lt;&lt; std::endl;  // `pre_x_suf\n\n    return 0;\n}\n</code></pre>"},{"location":"concepts/terms.html#buffer-size","title":"Buffer Size","text":"<p>Operations like grounding and renaming require buffer space for intermediate results. You can control this using buffer size functions.</p> TypeScriptPython <pre><code>import { buffer_size } from \"atsds\";\n\n// Get current buffer size\nconst current = buffer_size();\n\n// Set new buffer size (returns previous value)\nconst old = buffer_size(4096);\n</code></pre> <pre><code>import apyds\n\n# Get current buffer size\ncurrent = apyds.buffer_size()\n\n# Set new buffer size (returns previous value)\nold = apyds.buffer_size(4096)\n\n# Use context manager for temporary change\nwith apyds.scoped_buffer_size(8192):\n    # Operations here use buffer size of 8192\n    pass\n# Buffer size restored to previous value\n</code></pre>"},{"location":"concepts/terms.html#see-also","title":"See Also","text":"<ul> <li>Rules - How to create and work with inference rules</li> <li>Search Engine - Performing logical inference</li> </ul>"},{"location":"examples/basic.html","title":"Basic Examples","text":"<p>This section contains examples demonstrating the DS deductive system in various languages.</p>"},{"location":"examples/basic.html#propositional-logic-inference","title":"Propositional Logic Inference","text":"<p>The classic example demonstrates double negation elimination using propositional logic axioms:</p> <ul> <li>Modus Ponens: If P implies Q, and P is true, then Q is true</li> <li>Axiom 1: P \u2192 (Q \u2192 P)</li> <li>Axiom 2: (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))</li> <li>Axiom 3: (\u00acP \u2192 \u00acQ) \u2192 (Q \u2192 P)</li> </ul> <p>Given the premise !!X (double negation of X), we can derive X.</p> PythonTypeScriptC++ <pre><code>import apyds\n\n# Create a search engine\nsearch = apyds.Search(1000, 10000)\n\n# Modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\")\n# Axiom schema 1: p -&gt; (q -&gt; p)\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\")\n# Axiom schema 2: (p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r))\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\")\n# Axiom schema 3: (!p -&gt; !q) -&gt; (q -&gt; p)\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\")\n\n# Premise: !!X\nsearch.add(\"(! (! X))\")\n\n# Target: X (double negation elimination)\ntarget = apyds.Rule(\"X\")\n\n# Execute search until target is found\nwhile True:\n    found = False\n    def callback(candidate):\n        nonlocal found\n        if candidate == target:\n            print(\"Found:\", candidate)\n            found = True\n            return True  # Stop search\n        return False  # Continue searching\n    search.execute(callback)\n    if found:\n        break\n</code></pre> <pre><code>import { rule_t, search_t } from \"atsds\";\n\n// Create a search engine\nconst search = new search_t(1000, 10000);\n\n// Modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\n// Axiom schema 1: p -&gt; (q -&gt; p)\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\");\n// Axiom schema 2: (p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r))\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\n// Axiom schema 3: (!p -&gt; !q) -&gt; (q -&gt; p)\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\n\n// Premise: !!X\nsearch.add(\"(! (! X))\");\n\n// Target: X (double negation elimination)\nconst target = new rule_t(\"X\");\n\n// Execute search until target is found\nwhile (true) {\n    let found = false;\n    search.execute((candidate) =&gt; {\n        if (candidate.key() === target.key()) {\n            console.log(\"Found:\", candidate.toString());\n            found = true;\n            return true; // Stop search\n        }\n        return false; // Continue searching\n    });\n    if (found) break;\n}\n</code></pre> <pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n#include &lt;ds/utility.hh&gt;\n\nint main() {\n    ds::search_t search(1000, 10000);\n\n    // Modus ponens: P -&gt; Q, P |- Q\n    search.add(\"(`P -&gt; `Q) `P `Q\");\n    // Axiom schema 1: p -&gt; (q -&gt; p)\n    search.add(\"(`p -&gt; (`q -&gt; `p))\");\n    // Axiom schema 2: (p -&gt; (q -&gt; r)) -&gt; ((p -&gt; q) -&gt; (p -&gt; r))\n    search.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\n    // Axiom schema 3: (!p -&gt; !q) -&gt; (q -&gt; p)\n    search.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\n\n    // Premise: !!X\n    search.add(\"(! (! X))\");\n\n    // Target: X (double negation elimination)\n    auto target = ds::text_to_rule(\"X\", 1000);\n\n    // Execute search until target is found\n    while (true) {\n        bool found = false;\n        search.execute([&amp;](ds::rule_t* candidate) {\n            if (candidate-&gt;data_size() == target-&gt;data_size() &amp;&amp;\n                memcmp(candidate-&gt;head(), target-&gt;head(), candidate-&gt;data_size()) == 0) {\n                printf(\"Found: %s\", ds::rule_to_text(candidate, 1000).get());\n                found = true;\n                return true; // Stop search\n            }\n            return false; // Continue searching\n        });\n        if (found) break;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/basic.html#running-the-examples","title":"Running the Examples","text":"<p>Example files are provided in the repository under <code>examples/</code>:</p> <ul> <li><code>examples/main.py</code> - Python example</li> <li><code>examples/main.mjs</code> - TypeScript/JavaScript example</li> <li><code>examples/main.cc</code> - C++ example</li> </ul>"},{"location":"examples/basic.html#python","title":"Python","text":"<pre><code>pip install apyds\npython examples/main.py\n</code></pre>"},{"location":"examples/basic.html#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>npm install atsds\nnode examples/main.mjs\n</code></pre>"},{"location":"examples/basic.html#c","title":"C++","text":"<pre><code>cmake -B build\ncmake --build build\n./build/main\n</code></pre>"},{"location":"examples/sudoku.html","title":"Sudoku","text":""},{"location":"getting-started/installation.html","title":"Installation","text":"<p>DS can be installed for TypeScript/JavaScript, Python, or used directly as a C++ library.</p>"},{"location":"getting-started/installation.html#typescriptjavascript","title":"TypeScript/JavaScript","text":"<p>The TypeScript/JavaScript package <code>atsds</code> wraps the C++ core via WebAssembly.</p> <pre><code>npm install atsds\n</code></pre> <p>The package includes:</p> <ul> <li>WebAssembly binaries (<code>.wasm</code>)</li> <li>TypeScript type definitions (<code>.d.mts</code>)</li> <li>ES module support</li> </ul>"},{"location":"getting-started/installation.html#requirements","title":"Requirements","text":"<ul> <li>Node.js 20+ or a modern browser with WebAssembly support</li> </ul>"},{"location":"getting-started/installation.html#python","title":"Python","text":"<p>The Python package <code>apyds</code> wraps the C++ core via pybind11.</p> <pre><code>pip install apyds\n</code></pre>"},{"location":"getting-started/installation.html#requirements_1","title":"Requirements","text":"<ul> <li>Python 3.10-3.14</li> <li>Pre-built wheels are available for common platforms</li> </ul>"},{"location":"getting-started/installation.html#development-installation","title":"Development Installation","text":"<p>To install from source with development dependencies:</p> <pre><code>git clone https://github.com/USTC-KnowledgeComputingLab/ds.git\ncd ds\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation.html#c","title":"C++","text":"<p>The C++ library is the core implementation. Both Python and TypeScript bindings are built on top of it.</p>"},{"location":"getting-started/installation.html#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 compatible compiler</li> <li>CMake 3.30+</li> </ul>"},{"location":"getting-started/installation.html#building-from-source","title":"Building from Source","text":"<pre><code>git clone https://github.com/USTC-KnowledgeComputingLab/ds.git\ncd ds\ncmake -B build\ncmake --build build\n</code></pre>"},{"location":"getting-started/installation.html#using-in-your-project","title":"Using in Your Project","text":"<p>Include the headers from <code>include/ds/</code> in your C++ project:</p> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n</code></pre> <p>Link against the <code>ds</code> static library produced by the build.</p>"},{"location":"getting-started/installation.html#building-all-components","title":"Building All Components","text":"<p>To build all language bindings from source:</p>"},{"location":"getting-started/installation.html#typescriptjavascript-requires-emscripten","title":"TypeScript/JavaScript (requires Emscripten)","text":"<pre><code># Install Emscripten SDK first\n# https://emscripten.org/docs/getting_started/downloads.html\n\nnpm install\nnpm run build\n</code></pre>"},{"location":"getting-started/installation.html#python_1","title":"Python","text":"<pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation.html#c_1","title":"C++","text":"<pre><code>cmake -B build\ncmake --build build\n</code></pre>"},{"location":"getting-started/installation.html#verifying-installation","title":"Verifying Installation","text":"TypeScriptPythonC++ <pre><code>import { term_t } from \"atsds\";\n\nconst term = new term_t(\"(hello world)\");\nconsole.log(term.toString());\n</code></pre> <pre><code>import apyds\nprint(apyds.__version__)\n\n# Create a simple term\nterm = apyds.Term(\"(hello world)\")\nprint(term)\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto term = ds::text_to_term(\"(hello world)\", 1000);\n    std::cout &lt;&lt; ds::term_to_text(term.get(), 1000).get() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html","title":"Quick Start","text":"<p>This guide will help you get started with DS in your preferred language.</p>"},{"location":"getting-started/quickstart.html#creating-terms","title":"Creating Terms","text":"<p>Terms are the basic building blocks of the deductive system. A term can be:</p> <ul> <li>Variable: Prefixed with backtick, e.g., <code>`X</code>, <code>`P</code></li> <li>Item: Constants or functors, e.g., <code>a</code>, <code>father</code>, <code>!</code></li> <li>List: Ordered sequences in parentheses, e.g., <code>(a b c)</code></li> </ul> PythonTypeScriptC++ <pre><code>import apyds\n\n# Create different types of terms\nvar = apyds.Variable(\"`X\")\nitem = apyds.Item(\"hello\")\nlst = apyds.List(\"(a b c)\")\nterm = apyds.Term(\"(f `x a)\")\n\nprint(f\"Variable: {var}\")      # `X\nprint(f\"Item: {item}\")         # hello\nprint(f\"List: {lst}\")          # (a b c)\nprint(f\"Term: {term}\")         # (f `x a)\n</code></pre> <pre><code>import { variable_t, item_t, list_t, term_t } from \"atsds\";\n\n// Create different types of terms\nconst var1 = new variable_t(\"`X\");\nconst item = new item_t(\"hello\");\nconst lst = new list_t(\"(a b c)\");\nconst term = new term_t(\"(f `x a)\");\n\nconsole.log(`Variable: ${var1.toString()}`);  // `X\nconsole.log(`Item: ${item.toString()}`);      // hello\nconsole.log(`List: ${lst.toString()}`);       // (a b c)\nconsole.log(`Term: ${term.toString()}`);      // (f `x a)\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto var = ds::text_to_variable(\"`X\", 1000);\n    auto item = ds::text_to_item(\"hello\", 1000);\n    auto lst = ds::text_to_list(\"(a b c)\", 1000);\n    auto term = ds::text_to_term(\"(f `x a)\", 1000);\n\n    std::cout &lt;&lt; \"Variable: \" &lt;&lt; ds::variable_to_text(var.get(), 1000).get() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Item: \" &lt;&lt; ds::item_to_text(item.get(), 1000).get() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"List: \" &lt;&lt; ds::list_to_text(lst.get(), 1000).get() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Term: \" &lt;&lt; ds::term_to_text(term.get(), 1000).get() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html#creating-rules","title":"Creating Rules","text":"<p>Rules represent logical inference steps. A rule has premises (conditions) and a conclusion.</p> PythonTypeScriptC++ <pre><code>import apyds\n\n# A fact (rule with no premises)\nfact = apyds.Rule(\"(parent john mary)\")\nprint(f\"Fact: {fact}\")\n\n# A rule with premises\n# Format: premise1\\npremise2\\nconclusion\\n\nrule = apyds.Rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\")\nprint(f\"Rule premises: {len(rule)}\")\nprint(f\"Rule conclusion: {rule.conclusion}\")\n</code></pre> <pre><code>import { rule_t } from \"atsds\";\n\n// A fact (rule with no premises)\nconst fact = new rule_t(\"(parent john mary)\");\nconsole.log(`Fact: ${fact.toString()}`);\n\n// A rule with premises\nconst rule = new rule_t(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\");\nconsole.log(`Rule premises: ${rule.length()}`);\nconsole.log(`Rule conclusion: ${rule.conclusion().toString()}`);\n</code></pre> <pre><code>#include &lt;ds/ds.hh&gt;\n#include &lt;ds/utility.hh&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    auto fact = ds::text_to_rule(\"(parent john mary)\", 1000);\n    auto rule = ds::text_to_rule(\"(father `X `Y)\\n----------\\n(parent `X `Y)\\n\", 1000);\n\n    std::cout &lt;&lt; \"Fact: \" &lt;&lt; ds::rule_to_text(fact.get(), 1000).get() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Rule premises: \" &lt;&lt; rule-&gt;premises_count() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html#using-the-search-engine","title":"Using the Search Engine","text":"<p>The search engine performs logical inference by matching rules with facts.</p> PythonTypeScriptC++ <pre><code>import apyds\n\n# Create search engine\nsearch = apyds.Search(1000, 10000)\n\n# Add modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\")\n\n# Add axiom schemas\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\")  # Axiom 1\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\")  # Axiom 2\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\")  # Axiom 3\n\n# Add premise: !!X (double negation)\nsearch.add(\"(! (! X))\")\n\n# Define target: X\ntarget = apyds.Rule(\"X\")\n\n# Execute search\nwhile True:\n    found = False\n    def callback(candidate):\n        nonlocal found\n        if candidate == target:\n            print(f\"Found: {candidate}\")\n            found = True\n            return True\n        return False\n    search.execute(callback)\n    if found:\n        break\n</code></pre> <pre><code>import { rule_t, search_t } from \"atsds\";\n\n// Create search engine\nconst search = new search_t(1000, 10000);\n\n// Add modus ponens: P -&gt; Q, P |- Q\nsearch.add(\"(`P -&gt; `Q) `P `Q\");\n\n// Add axiom schemas\nsearch.add(\"(`p -&gt; (`q -&gt; `p))\");  // Axiom 1\nsearch.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");  // Axiom 2\nsearch.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");  // Axiom 3\n\n// Add premise: !!X (double negation)\nsearch.add(\"(! (! X))\");\n\n// Define target: X\nconst target = new rule_t(\"X\");\n\n// Execute search\nwhile (true) {\n    let found = false;\n    search.execute((candidate) =&gt; {\n        if (candidate.key() === target.key()) {\n            console.log(\"Found:\", candidate.toString());\n            found = true;\n            return true;\n        }\n        return false;\n    });\n    if (found) break;\n}\n</code></pre> <pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;ds/ds.hh&gt;\n#include &lt;ds/search.hh&gt;\n#include &lt;ds/utility.hh&gt;\n\nint main() {\n    ds::search_t search(1000, 10000);\n\n    // Add modus ponens: P -&gt; Q, P |- Q\n    search.add(\"(`P -&gt; `Q) `P `Q\");\n\n    // Add axiom schemas\n    search.add(\"(`p -&gt; (`q -&gt; `p))\");\n    search.add(\"((`p -&gt; (`q -&gt; `r)) -&gt; ((`p -&gt; `q) -&gt; (`p -&gt; `r)))\");\n    search.add(\"(((! `p) -&gt; (! `q)) -&gt; (`q -&gt; `p))\");\n\n    // Add premise: !!X (double negation)\n    search.add(\"(! (! X))\");\n\n    // Define target: X\n    auto target = ds::text_to_rule(\"X\", 1000);\n\n    // Execute search\n    while (true) {\n        bool found = false;\n        search.execute([&amp;](ds::rule_t* candidate) {\n            if (candidate-&gt;data_size() == target-&gt;data_size() &amp;&amp;\n                memcmp(candidate-&gt;head(), target-&gt;head(), candidate-&gt;data_size()) == 0) {\n                printf(\"Found: %s\", ds::rule_to_text(candidate, 1000).get());\n                found = true;\n                return true;\n            }\n            return false;\n        });\n        if (found) break;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart.html#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about Terms</li> <li>Understand Rules</li> <li>Explore the Search Engine</li> <li>Check the API Reference</li> </ul>"}]}